id,subject,message
62481,2019AA שאלה 2 סעיף א,"היי,

אין לסעיף הזה פתרון בפתרונות הרשמיים, אשמח לפידבק על הפתרון שלי.

לדעתי ניתן להוסיף את הפעולה בזמן O(1) אפילו בw.c על ידי הגדלת הערך של a בd, ולבצע בדיקה האם הערך החדש קטן מהערך של Succ(a). אם כן, סיימנו. אם לא, נחליף ביניהם בשינוי פוינטרים בO(1). מובטח שהערך החדש קטן מSucc(Succ(a)) לכן לאחר ההחלפה כלל הערימה לא מופר. ומינימום הערימה לא יכול להשתנות כי מובטח שהוא לא a."
63232,תשובה ל: 2019AA שאלה 2 סעיף א,"הפתרון נכון.

שים לב שזה שהפתרון הוא O(1) WC לא אומר עדיין שהאמורטייזד שלו בתוך ה""bundle"" עם שאר הפעולות הוא O(1).
ספציפית בשאלה הזאת זה ברור כי המימוש שלך לא משפיע על פונקציית הפוטנציאל שאיתה הוכיחו את זמני האמורטייזד של שאר הפעולות."
69399,תשובה ל: 2019AA שאלה 2 סעיף א,"שלום,

בשקופית 70 במצגת של הרצאה 8 כשהגדרנו ערימת פיבונאצ'י אמרנו שכל אחד מהילדים מחזיק מצביע להורה שלו. על כן, לא ברור לי איך נעשה שינוי של כל המצביעים של הילדים של צומת מסויים ב-O(1).
אשמח אם תוכל להסביר כיצד הדבר מתבצע.

תודה רבה!"
69495,תשובה ל: 2019AA שאלה 2 סעיף א,אפשר רק להחליף את המפתחות בין 2 הnodes ולא להחליף את המצביעים ל nodes
70048,שאלת המשך לסעיף ב',"היי ,

לגבי סעיף ב' בשאלה , לא הצלחתי להבין למה אם אנחנו מבצעים n פעמים findMin הסיבוכיות של כל findMin נשארת o(1)? אם מוחקים את המינימום אנחנו עלולים לשלם n בכל איטרציה ואם אנחנו מחפשים בעץ שנוצר אחרי המחיקה הראשונה logn. 
תודה"
70065,תשובה ל: שאלת המשך לסעיף ב',"אני חושבת שהכוונה בפתרון היא שלא מוחקים את המינימום, אלא רק משנים את הערך שלו לאינסוף. כדי להפריך צריך להניח שincreaseKey קורה בO(1) אמורטייזד כולל מציאת המינימום החדש, למרות שאנחנו יודעים שבערמת פיבונאצי זה לא הגיוני, אבל זה לא משנה, אנחנו גם ככה מנסים להפריך את זה."
70077,תשובה ל: שאלת המשך לסעיף ב',"לא הבנתי למה הסקת שincreaseKey כולל בתוכו findMin ? אם אנחנו עושים רק Inserts אנחנו יכולים לתחזק שדה שאומר מי המינימום. אבל אם אנחנו עושים inreaseKey למינימום , פוטנציאלית כל אחד מבין n האיברים בערימה יכול להיות המינימום החדש עכשיו וצריך לחפש אותו מבין כולם ."
70111,תשובה ל: שאלת המשך לסעיף ב',"נכון, ובגלל זה כמו שאתה אומר זה באמת לא אפשרי לעשות את increaseKey בO(1) אמורטייזד, כי אנחנו נהיה חייבים שהמתודה תדאג לתחזק גם היא את המינימום ואי אפשר לעשות את זה בזמן קבוע באמורטייזד. אבל, זה לא הוכחה. ולכן תניח בשלילה שהיית יכול לעשות דבר כזה, אפילו להשיג את המינימום החדש בכל increaseKey בO(1) אמורטייזד, ואז תגיע לסתירה."
70118,תשובה ל: שאלת המשך לסעיף ב',"תודה לירון.
בסעיף ב אסור להניח מימוש קונקרטי, צריך להוכיח שלא קיים אף מימוש של הADT עם זמני האמורטייזד של השאלה"
79346,תשובה ל: שאלת המשך לסעיף ב',בעצם בגלל שהincreaseKey הוא O1 אמורטייזד אז יוצא שהמיון הוא On אמורטייזד? וזה עדיין סותר את החסם התחתון?
80137,תשובה ל: שאלת המשך לסעיף ב',"המיון יצא O(n) ב WC.

כשמדברים על אמורטייזד אז מדברים על העלות הממוצעת של פעולה בתוך סדרת פעולות, אין משמעות ללומר שסדרת פעולות היא O(f(n)) אמורטייזד.
כאן הייתה לנו סדרה של פעולות וניתחנו את העלות של הסדרה כולה על סמך המידע על זמני האמורטייזד."
82151,תשובה ל: 2019AA שאלה 2 סעיף א,"היי נתן,

מדוע הפיתרון נכון? למה הבדיקה של העוקב מבטיחה שלא הופר כלל הערימה? הרי בערימה בכלל אין סדר מוחלט בין המפתחות, אנו יודעים יכול להיות שהעוקב אפילו לא באותו עץ איתו. או שאני מפספסת משהו?"
64775,2022Bb שאלה 2,"שלום,
בתשובה לשאלה זו אין התייחסות להתנגשות של 2 מפתחות שונים בטבלה, דבר שאם קורה מערער את נכונות הקוד, אשמח להתייחסות איך מטפלים בנושא."
64843,תשובה ל: 2022Bb שאלה 2,"אין צורך לדבר על זה כי מבחינתך אתה עובד עם מילון והמימוש מאחורי הקלעים לא צריך להדאיג אותך.

כל האלגוריתם עדיין היה נכון מילה במילה אם המילון D היה ממומש על ידי עץ AVL."
65235,תשובה ל: 2022Bb שאלה 2,"קצת לא הבנתי את התשובה, מצויין בפירוש שהמילון הוא טבלת hash, וגם לפי השאלה אני הבנתי שרוצים שנציין את זה, אך למדנו שבhash יכולים שני מפתחות שונים להתנגש, במקרה הזה התנגשות אומר שיש 2 ערכים במילון עם מרחק שונה מהחציון אבל באותו תא בhash, מה שדופק את הקוד. אם המילון היה ממומש על ידי AVL אז הסיבוכיות הייתה Onlogn בWC ולא On בתוחלת, אז או שהסיבוכיות פה לא נכונה או שהמימוש לא נכון, אם אפשר להבהיר בבקשה מה מהם, תודה רבה"
65310,תשובה ל: 2022Bb שאלה 2,"אני מתכוון שבפתרון הוצג אלגוריתם המשתמש במילון. מבחינתך לא אמור להיות אכפת איך המילון ממומש, רק שהוא מבצע את פעולות הADT כמו שרצית.
זה שמדובר על טבלת hash משפיע רק על הסיבוכיות ולא על נכונות האלגוריתם."
64822,אתחול מערך זמן קבוע,"שלום,
בהרצאה 1 למדנו על כך שאפשר לתחזק מערך (וקטור) שמאותחל בזמן קבוע, ניתן להשתמש בכך בשאלות במבחן, בשימוש המימוש שלמדנו בכיתה?"
64845,תשובה ל: אתחול מערך זמן קבוע,כן
64920,2022 Bb שאלה 1 סעיף ב,"לא הצלחתי להבין למה 

m=o(n^3)

האם מכיוון שהתוחלת קטנה מ  1 ?

תודה"
65088,תשובה ל: 2022 Bb שאלה 1 סעיף ב,"אנחנו מחפשים את הm הכי קטן שעבורו מתקיים האי שיוויון. אם מציבים m = n^3 אז מתקיים האי שיוויון, כלומר הm שאנחנו מחפשים הוא O(m^3)"
64940,מבחן 2022AB שאלה 5 סעיף ב,"אני לא מבין את המעבר המודגש בתמונה,

איך מסכומים של S קיבלנו Sk-1 + Sk-3?

תודה"
65091,תשובה ל: מבחן 2022AB שאלה 5 סעיף ב,"צריך להוכיח באינדוקציה ש s_0 + s_0 + s_0 + s_1 + ...s_(k-3) = s_(k-1) עבור k>=4

בסיס k=4: מתקיים s_0 + s_0 + s_0 +s_1= 5 = S_3

צעד k->k+1:
s_0 + s_0 + s_0 + s_1 +... +s_(k-3)+s(k-2) =
s_(k-1)+s_(k-2) =
s_k"
72269,תשובה ל: מבחן 2022AB שאלה 5 סעיף ב,"הי,
לא הצלחתי להבין למה הוכחת s_0 + s_0 + s_0 + s_1 + ...s_(k-3) = s_(k-1) עבור k>=4
מסבירה לנו את המעבר:
s_0 + s_0 + s_1 + ... + s_(k-3) = s_(k-1) + s_(k-3)
?"
72681,תשובה ל: מבחן 2022AB שאלה 5 סעיף ב,"מצטער, נראה שהטעתי בפתרון הקודם שלי.

איך שצריך לנסח את הפתרון הוא

s_k = s_0 + s_0 + s_0 + s_1 + ...s_(k-3)

ולכן s_k - s_(k-1) = s_(k-3) (בגלל שכל הגורמים בנוסחה למעלה יצטמצמו פרט לגורם בודד).
לכן s_k = s_(k-1) + s_(k-3)"
72766,תשובה ל: מבחן 2022AB שאלה 5 סעיף ב,הבנתי תודה רבה
65709,2020AA שאלה 5 סעיף ב,"היי,

בפתרון לסעיף ב' אתחלו טבלת hash בגודל n, אבל במימוש PrintAllSailingsToday() מוחקים אונייה מהיום הנוכחי k ומעבירים אותה ליום הנוכחי פלוס מחזור ההפלגה, כלומר k+Db. אבל זה אומר שבכל קריאה לפונקציה נכניס מפתח חדש לטבלה וכמות המפתחות השונים לא מוגבלת. זה לא יפגע בזמן הריצה בתוחלת כי הטבלה היא בגודל n בלבד?"
65855,תשובה ל: 2020AA שאלה 5 סעיף ב,"כמות המפתחות חסומה על ידי כמות הספינות n.

מה שכן, היה צריך להוסיף לסעיף ב את הנתון ש n ידוע מראש."
65885,תשובה ל: 2020AA שאלה 5 סעיף ב,"כמות המפתחות ההתחלתית חסומה על ידי כמות הספינות n אבל הכוונה שלי היא שאם נכניס לטבלה ספינה למשל במפתח מספר 1 (יום 1), ואחכ כל פעם ב-PrintAllSailingsToday נמחק ונוסיף אותה במפתח 8 (נגיד עם מחזור של שבוע) ואז שוב במפתח 15,22,29 וכו אז כמות המפתחות הזו אין סופית וכבר לא חסומה על ידי כלום. מה אני מפספסת?"
66088,תשובה ל: 2020AA שאלה 5 סעיף ב,"כמות המפתחות ממשיכה להיות חסומה על ידי n.

נעזרים במילון (שספציפית ממומש עם טבלת hash) שהמפתח הוא יום והvalue הוא רשימה מקושרת.
ב printAllSailings מחפשים את המפתח של היום (נסמן ב k) הנוכחי ומקבלים את הvalue שלו שהוא רשימה מקושרת של הספינות שיוצאות היום. כל ספינה כזאת מוחקים מהרשימה המקושרת של הvalue, מחפשים במילון את יום היציאה הבא שלה ומוסיפים לרשימה המקושרת המתאימה. בסוף התהליך מוחקים את k מהמילון."
66089,תשובה ל: 2020AA שאלה 5 סעיף ב,"כלומר כל key מתאים ליום הפלגה של ספינות.
בנוסף כל ספינה יושבת בדיוק ברשימה מקושרת אחת שהיא ה value המתאים לkey המתאר את תאריך ההפלגה הקרוב של הספינה."
65769,תחזוק מערך שגודלו משתנה,"היי,

ראינו באחת ההרצאות הראשונות שניתן לתחזק מערך באופן דינמי (מערך שגודלו משתנה בהתאם לכמות הערכים שאינם ״זבל״ בתוכו) ב- O(1)  אמורטייזד. האם ניתן להשתמש בכך במבחן?"
65865,תשובה ל: תחזוק מערך שגודלו משתנה,"כן.
יותר מזה, ראיתם גם איך לעשות לתהליך דה אמורטיזציה ולקבל מערך שגודלו משתנה ב O(1) במקרה הגרוע."
65777,2022AA שאלה 3ב,"שלום,
בשאלה זו בסעיף ב', בפתרון הרשמי חילקו את המערך למקטעים בגודל שורש n, נניח n שווה 9 אזי שורש n שווה 3 כלומר האיבר במקום 1 במערך הממויין (נניח מתחיל מ1) יכול להיות במקומות 1 עד 4 כולל (i+k כאשר i זה 1 וk זה 3), אבל אם נחלק את המערך לבלוקים בגודל 3 שזה שורש n נקבל כי בכל פרמוטציה של הבלוק הראשון האיבר במקום 1 אף פעם לא יהיה במקום הרביעי, כלומר תנאי השאלה לא מתקיים, אשמח להתייחסות.

כמו כן אשמח להתייחסות לגבי האם הוכחה אלגברית של nlog (n^0.5) = אומגה של nlogn תופסת במקרה הזה, תודה"
65862,תשובה ל: 2022AA שאלה 3ב,"שים לב שאנחנו מתחילים ממערך ממויין ורק רוצים לייצר כמה שיותר פרמוטציות שלו שמקיימות שכל איבר הוא במרחק לכל היותר 3 מהמיקום הממויין, אם גרמנו לזה שהמרחק הוא לכל היותר 2 אז זה עדיין סבבה.
(אנחנו רוצים לתת חסם תחתון על כמות העלים בעץ ההשוואות, או במילים אחרות - בהנתן מערך קלט כללי a1 a2 ... an, איזה פרמוטציות שלו האלגוריתם חייב להיות מסוגל להחזיר).

לא מבין את השאלה השנייה"
72287,תשובה ל: 2022AA שאלה 3ב,"היי,
אני עדיין לא מצליחה להבין כל כך את הפתרון של השאלה.
מה שמבלבל אותי זה שבכיתה בשאלות כאלה לקחנו קלט כללי שעונה על הדרישות הרלוונטיות לשאלה ודיברנו על מספר הפלטים האפשריים שלו ואז עשינו לוג כדי לקבל חסם תחתון.
פה בפתרון הם מתייחסים לקלט ספציפי בהתאם לפלט ספציפי עליו החליטו. אני קצת לא מצליחה להבין מה ניסו לעשות כאן ומתי זה אפשרי/חוקי"
72594,תשובה ל: 2022AA שאלה 3ב,"נתן הסביר את זה בשעת קבלה
הוא אמר שבשביל חסם תחתון בעץ השוואות צריך למצוא את כמות הפלטים האפשריים של האלגוריתם ולקחת עליו לוג, אבל שבמקרה הזה קשה למצוא ביטוי לכמות הפלטים האפשריים, אז ניקח איזשהי תת קבוצה של הפלטים האפשריים שאנחנו כן יודעים לחשב את הגודל שלה, ונראה שאפילו אם לוקחים לוג רק על הגודל שלה, זה יוצא אומגה של nlogn.
בשביל זה נחלק מערך ממויין לשורש n בלוקים בגודל שורש n, וניקח את כל צירופי הפרמוטציות האפשריים של הבלוקים האלה - זה עומד בתנאים של השאלה כי כל איבר נמצא במרחק של לכל היותר שורש n מהמקום שלו במערך הממויין, כי עשינו shuffle רק בתוך בלוקים בגודל שורש n. ברור שזה לא כל הפלטים האפשריים אבל אפילו אם לוקחים את כמות המערכים הזאת רואים שזה nlogn"
65859,שאלה לגבי המבחן,"האם בnvלך המבחן כדי למנוע בלבולי אינדקסולוגיה, אפשר לכתוב הנחות כמו ""נניח שאינדקסי המערך הם מ1 עד n"" ?"
65863,תשובה ל: שאלה לגבי המבחן,"כן, בכל שאלה צריך לציין בנפרד אם אתה עושה נוטציה כזאת."
65968,2022AB שאלה 2א,אפשר בבבקשה הסבר ללמה הטעות נפוצה היא טעות? אלו כמות האיברים שאנחנו נפטרים מהם כל איטרציה.
66068,תשובה ל: 2022AB שאלה 2א,אפשר גם להסביר בבקשה למה בסעיף ב' המקרה כן עובד ובו אפשר להוריד מחלק מהשישיות 2 איברים ומחלק מהשישיות 3 איברים?
66093,תשובה ל: 2022AB שאלה 2א,"לא בהכרח נפטרים מהאיברים האלה.
יכול להיות מצב שהחציון שתקבל רקורסיבית גדול מכל האיברים שהיו השניים בגודלם בשישייה וקטן מכל האיברים שהיו השלישיים בגודלם בשישייה.
במקרה הזה אפשר לומר שנפתרים רק מ2 איברים עבור כל אחד מהאיברים שקטנים מהחציון הרקורסיבי (חצי מ n/6)"
66096,תשובה ל: 2022AB שאלה 2א,בסעיף ב כן לוקחים גם וגם כי אי אפשר לומר שהחציון הרקורסיבי גדול רק מהאיברים שהיו השניים בגודלם (יש רק n/6 * 1/3 כאלו והחציון הרקורסיבי צריך להיות גדול מ n/6 * 1/2 איברים)
68269,מבחן 2017BA שאלה 3ג,"היי :) אשמח לעזרה עם השאלה הזאת: 

ראיתי פתרון שמציע את המבנה הבא: מבנה המכיל שני עצי AVL, ורשימה מקושרת L: עץ T1 יכיל את כל איברי המבנה, בתוספת שדה ""DELETED"" שיסמן האם האיבר מחוק או לא. 
עץ T2 יכיל את כל המפתחות שנמחקו אי פעם מהמבנה. כל צומת בעץ יכיל בנוסף את השדה ""STILL DELETED"" שיסמן האם עדיין לא קיים שום איבר במבנה בעל מפתח כזה.
הרשימה L תכיל את כל האיברים שנמחקו מהעץ אך לא עודכנו בT2. 
הפעולות ימומשו באופן הבא: 
1. DELETE - נבצע מחיקה ""עצלה"" של האיבר מהמבנה ע""י כך שנשנה את שדה DELETED שלו בT1 לTRUE. בנוסף, נוסיף את האיבר לרשימה המקושרת L. 
2. INSERT, EVERDELETED, STILLDELETED - נכניס כל מפתח של איבר בL לT2 בצורה הבאה: 
    - אם המפתח של האיבר נמצא בT2, נעדכן את שדה STILL DELETED שלו לTRUE.
    - אם המפתח של האיבר לא נמצא בT2, נוסיף אותו לעץ T2 (בעלות O(LOG K)) עם שדה STILL DELETED מעודכן לTRUE. 
    נמחק את האיבר מהרשימה L.
    לאחר מכן נבצע את הפעולה המתאימה כרגיל כפי שפתרנו בסעיפים הקודמים:

    INSERT: הוספה של האיבר לT1 וחיפוש המפתח בT2. אם המפתח קיים, נעדכן את STILL DELETED של האיבר לFALSE.

    EVERDELETED: חיפוש המפתח בT2, אם נמצא אותו נחזיר TRUE, אחרת FALSE.

    STILLDELETED: חיפוש המפתח בT2 והחזרת שדה STILL DELETED שלו.

אני מתקשה להבין למה הפתרון הזה עונה על דרישות הסיבוכיות בAMORTIZE, זה פתרון שקיבל ניקוד מלא. 

תודה מראש :)"
68516,תשובה ל: מבחן 2017BA שאלה 3ג,"פישלנו קצת בניסוח של התרגיל בגלל שלא ציינו את זמן האמורטייזד של Delete ובלי שציינו את זמני האמורטייזד של כל הפעולות אז אמורטייזד לא מוגדר (חוץ מאם מסתכלים על סדרת פעולות בלי delete אבל אז זה לא מעניין).
התכוונו לדרוש בנוסף שהאמורטייזד של delete הוא O(1).

הוכחת האמורטייזד נראית ככה:

נימוק קצר וקביל - כמות פעולות המחיקה קטנה או שווה לכמות פעולות ההכנסה (כלומר k <= #insert <= n) ולכן ניתן לחייב את כל העבודה הקשורה ל L לפעולת insert.

נימוק שקול ויותר מהגדרה - תהי סדרה של n פעולות, נחסום את זמן הריצה שלה ונראה שזמני האמורטייזד עונים על ההגדרה (שמתקיים אי השיוויון שמגדיר אמורטייזד).
נבחין כי פרט לעבודה הקשורה ל L (כל מה שתיארת ב5 שורות שהגיעו אחרי התיאור של delete) העלות של הפעולות הן -
insert - logn
everdelete - logk
stilldeleted - logk
delete - 1
בנוסף, נבחין כי סך העלות של הפעולות הקשורות ל L היא לכל היותר klogk (בגלל שעובדים בפעולות האלה רק על העץ T2 ומכניסים לL לכל היותר k איברים).
לכן נקבל:"
68518,תשובה ל: מבחן 2017BA שאלה 3ג,
68519,תשובה ל: מבחן 2017BA שאלה 3ג,"המונח ""נחייב"" שאמרתי בפתרון המקוצר הוא מונח סטנדרטי והמשמעות שלי היא בדיוק האי שיוויון שביצענו בתמונה למעלה (הוספנו למה שמכפיך את #insert גם את ה klogk הסגול)"
68596,תשובה ל: מבחן 2017BA שאלה 3ג,"תודה רבה, זה היה ממש מובן!
אז בעצם באותה מידה הפתרון של השאלה היה יכול להיות אותו דבר רק שבמקום ששלושת הפעולות ייקחו איברים מL ויעבירו לT2, שרק פעולת insert תעשה את זה והניתוח סיבוכיות היה אותו הדבר?"
68687,תשובה ל: מבחן 2017BA שאלה 3ג,"לדעתי לא - במצב של n הכנסות ואז n מחיקות, כל EverDeleted על האיבר האחרון בL יהיה בזמן O(n), ואז לעשות עוד n פעולות כאלה יקח n^2, סהכ עבור 3n פעולות ביצעת סיבוכיות של יותר מn^2 ולכן האמורטייד של everDeleted יהיה לינארי"
68803,תשובה ל: מבחן 2017BA שאלה 3ג,"מה שעומר אמר.
חובה מיד לפני כל פעולה (everdeleted stilldelete) לרוקן את הרשימה L כי אחרת לא נדע להחזיר תשובה נכונה בזמן סביר"
70530,תשובה ל: מבחן 2017BA שאלה 3ג,"יש מצב להסבר למה בפתרון הזה ה delete היא ב O(1) wc? הרי כדי לשנות את השדה צריך למצוא את האיבר שמוחקים, ו ב wc זה O(logn). תודה לעוזרים"
70546,תשובה ל: מבחן 2017BA שאלה 3ג,"הבנתי, לא חשוב:)"
68992,מבחן 2017ba שאלה 4ב,אשמח לקבל כיוון לפתרון של שאלה 4 סעיף ב :
69114,תשובה ל: מבחן 2017ba שאלה 4ב,"בניסוח של השאלה היו צריכים לציין גם את זמני האמורטייזד של הפעולות, נעשה כמו הWC שביקשו.

הטריק דומה יחסית למה שהיה לנו בתרגול עם הערימות מינימום-מקסימום

נתחזק עץ AVL בשם T עבור k האיברים הקטנים ביותר ובנוסף ערימת פיבונאצי (מינימום) בשם H עבור שאר n-k האיברים.

הכנסה של x - אם x גדול מהמקסימום של T אז נכניס לH. אחרת, נכניס את x ל T, נמחק מT את המקסימום ונכניסו ל H.

מחיקה בהנתן מצביע ל x - אם x שייך ל T אז נמחק אותו, לאחר מכן נמחק את המינימום מH ונכניס אותו ל T (הוא יהיה המקסימום החדש של T). אם x שייך ל H אז נמחק אותו וזהו.

select - ביצוע select בתוך T (צריך שב T יהיה שדה size)"
69115,תשובה ל: מבחן 2017ba שאלה 4ב,
69119,תשובה ל: מבחן 2017ba שאלה 4ב,"בסעיף הזה יש טריק נוסף -

נשארים עם אותו מבנה נתונים כמו מקודם.

decrease key של x - אם x שייך ל T אז מוחקים אותו משם ומכניסים מחדש. אם x שייך ל H אז עושים לו decKey רגיל. אם יצא ועכשיו x הוא המינימום של H אז אולי צריך להעביר אותו ל T:
נשווה את x אם המקסימום של T, אם x גדול יותר אז לא עושים כלום. אם x קטן יותר אז כאן מגיע הטריק: נחליף בין המפתח של x לבין המפתח של המקסימום ב T ונסיים. (אם היינו מוחקים את x מH ומכניסים ל T ומוחקים את המקסימום של T ומכניסים ל H אז זה היה יקר מדי כי המחיקה של x מH תעלה logn אמורטייזד)."
69987,תשובה ל: מבחן 2017ba שאלה 4ב,"למה אפשר פשוט להחליף את המפתחות? יכול להיות שלצמתים יש עוד מידע שהם מחזיקים ואז אנחנו מאבדים אותו
זאת אומרת, אם עושים את ההחלפה נעשה החלפת פוינטרים של כל הצומת לא?"
69989,תשובה ל: מבחן 2017ba שאלה 4ב,"יש פה איזו דקות - החלפה בין המפתחות יכולה להיות בעייתית. יכול להיות שנעשה decrease key בH ועכשיו הערך בו יהיה קטן אפילו מהמינימום בT. כלומר המיקום שלו לא אמור להיות בראש הערימה של T.
לכן נצטרך למחוק את המקסימום של T ולהכניס את האיבר החדש לT ב O(logk)"
70167,תשובה ל: מבחן 2017ba שאלה 4ב,"שרון - אפשר לחשוב על כל איבר כאל אובייקט עם key,value ופוינטר ל node שהוא יושב בו בערימה/מבנה נתונים אחר. אני אומר שנחליף בין הפוינטרים האלה.
שרה - צודקת, תודה"
68999,מבחן 2020AB שאלה 5,"אהלן,

בפתרון של שאלה 5 כתוב כי בכל איטרציה של פעולת MATCH נבצע מחיקה אחת של המקסימום. לא הבנתי למה מתבצעת בהכרח רק מחיקה אחת, הרי למשל, אם שני הערכים הגבוהים ביותר נתונים עבור רקדן i, כאשר נמחק את המקסימום, אז באיטרציה הבאה הוא עדיין הרקדן עם הערך המקסימלי אבל הוא כבר לא מעניין אותנו כי מצאנו לו זיווג."
69096,תשובה ל: מבחן 2020AB שאלה 5,יכול לצרף את השאלה?
69287,תשובה ל: מבחן 2020AB שאלה 5,
69502,תשובה ל: מבחן 2020AB שאלה 5,"יכולים לבצע יותר ממחיקה אחת של של מקסימום, בתיאור הפעולה רשום ""וחוזרים על התהליך"" ובניתוח של match אמרו שבכל איטרציה פנימית של match יש מחיקת מקסימום אחת"
69855,תשובה ל: מבחן 2020AB שאלה 5,"אז לא הבנתי למה בכל איטרציה יש מחיקת מקסימום אחת, הרי יכול להיות שהמקסימום הבא או של הרקדן שהרגע מצאנו את המקסימום שלו ואז נצטרך למחוק יותר מאחד לא?"
70123,תשובה ל: מבחן 2020AB שאלה 5,הכוונה היא שפעולת match אחד מכילה כמה איטרציות של מחיקה. ממשיכים למחוק את שמקבלים זוג תקין
71069,תשובה ל: מבחן 2020AB שאלה 5,אשמח להסבר בבקשה איך מגיעים לפונקצית הפוטנציאל הזו
71112,תשובה ל: מבחן 2020AB שאלה 5,"אתה רוצה שבמידה וביצעת x מחיקות מהערימה (מה שעולה xlogn ומקטין בx את גודל הערימה) אז הפוטנציאל ירד באותה כמות.

דרך יותר אינטואיטיבית לעשות כאן את הניתוח אמורטייזד זה בשיטת הנק: בכל הכנסה לשים 2logn מטבעות לבנק ובכל מחיקה לשם logn מטבעות.
נשים לב שההוכחה הזאת יכולה לתת עוד זווית ראיה על למה פונקציית הפוטנציאל ממקודם הגיונית: יוצא שמאזן הבנק שלנו הוא לפחות size(H)*logn"
82136,תשובה ל: מבחן 2020AB שאלה 5,תוכל לחדד למה מאזן הבנק שלנו הוא לפחות size(H)*logn ?
69131,2018BA שאלה 3,"אוכל סרטים על השאלה הזאת, אפשר עזרה?"
69134,תשובה ל: 2018AB שאלה 3,"א - רשימה מקושרת

ב' - ניתן לפתור עם tree list, בו כל הפעולות יקחו זמן לוגריתמי. Concat יהיה בעצם join של שני עצי AVL. יש לשים לב שלא צריך לשמור את האינדקס בתוך מפתח - ניתן לעשות retrieve באמצעות פעולת select."
69137,תשובה ל: 2018AB שאלה 3,"סעיף ג -
UF על ה*אובייקטים* L_i. כל אובייקט מצביע לרשימה מקושרת.
כאשר עושים insert לאובייקט L אז עושים הכנסה רגילה לרשימה מקושרת ודואגים שהאיבר שהוכנס יצביע לL.
כאשר עושים retrieve אז מטיילים על הרשימה המקושרת.
כאשר עושים concat(L1,L2) אז משרשרים את הרשימות המקושרות של L_1,L_2 ובנוסף עושים union לאובייקטים L_1,L_2. נחליט שהשורש החדש שהתקבל הוא האובייקט L_1 והוא יצביע לרשימה המקושרת הגדולה שנוצרה.
whichList(A) - בהנתן איבר A, נסתכל על איזה אובייקט L הוא מצביע (הרשימה המקורית אלייה הוא היה שייך) ונעשה find(L)."
69138,תשובה ל: 2018AB שאלה 3,"סעיף ד -
כמו סעיף ב (שהכל בוצע בlogn בעזרת tree-list), רק שהפעם גם נשמור finger לצומת ה""מינימלי"" (לפי הסדר in order).
מה שהיינו רוצים לומר עכשיו זה שאנו עושים select(i) בזמן log(i( ואז הrebalance הוא O(1( אמורטייזד.
הבעיה בגישה הזאת היא שבשביל לבצע select(i) מהיר בהכנסה אנו צריכים לתחזק שדה size בעץ וכאשר אנו עושים הכנסה ליד המינימום אז ""אין ברירה"" אלה לתקן את השדה size עד לשורש.

הפתרון: (שאין מצב שזה מה שהם רצו)
נבחין כי לאחר הrebalance הסטנדרטי של AVL המתבצע בinsert(x,i) מתקיים שהצמתים היחידים שהשדה size שלהם הוא לא תקין הם הצמתים במסלול מהשורש אל ה""מינימום"".
לכן אפשר בinsert לא לתקן את השדה size עד השורש אלה רק לבצע את התיקונים לשדה size בזמן פעולות הrebalance הסטנדרטיות של AVL. (זה משאיר רישא מהמסלול מהשורש אל המינימום לא תקין)
נשים לב שבגלל שsize הוא שדה שניתן לחשב על סמך השדה של הבנים, אז אפקטיבית במהלך פעולות הInsert הבאות, אנו יכולים לחשוב על השדה size כתקין (אנו מתחילים מהfinger וכל פעם שאנו עולים למעלה, אנחנו מחשבים מחדש את size של הצומת הנוכחי על סמך השדה של הבנים).

סעיף ה -
שילוב של מבנה הtree-list של סעיף ב עם הניתוח אמורטייזד של UF שמומש עם רשימות מקושרת (כשמאחדים 2 עצים אז מעתיקים את כל המצביעים מהעץ הקטן לשורש של העץ הגדול. יוצא שכל צומת עשה לכל היותר logn העתקות במהלך ריצת התוכנית)."
79791,תשובה ל: 2018AB שאלה 3,"אשמח להסבר למה בסעיף ב' join עונה על הדרישה, הרי אנחנו יודעים שזה שקול ל""שרשור"" של אחד העצים לאחר ובפרט זה לא יגרום לכך ששני העצים יפסיקו להתקיים ונקבל עץ שלישי חדש, אלא פשוט שעץ אחד הפסיק להתקיים והוא עכשיו חלק מהעץ האחר. תודה מראש."
80128,תשובה ל: 2018AB שאלה 3,בהגדרה של concat ניתן להניח שאין למשתמש יותר גישה ל L1 ו L2 ולכן מותר להרכיב בעזרתן את הרשימה הסופית
69140,2020BB שאלה 6,שאלה 
69141,תשובה ל: 2020BB שאלה 6,"ההבחנה היא כמות הערכים במערך יכולה רק לקטון ושקבוצות ערך יכולות להתאחד, זה מוביל אותנו לחשוב לכוון של UF.

נעשה מבנה UF על האינדקסים של המערך. נרצה שכל האינדקדסים שמתאימים לאותו ערך יהיו באותה קבוצה ובשורש שלה נשמור את הערך הזה.

הסיבה שצריך hash היא שבהינתן ערך אז לא יודעים בהכרח לאיזו קבוצה הוא שייך לכן נשמור במילון (שממומש עם טבלת האש) לכל ערך x את השורש של העץ שמתאים לקבוצת האינדקסים עם הערך הזה.

init - בשלב הזה אנחנו צריכים לייצר את הקבוצות שלנו בשביל הUF. נכניס את כל איברי המערך למילון (שממומש עם טבלת hash כדי שזה יהיה זמן קבוע בתוחלת) כאשר המפתח שלפיו הם נכנסים למילון הוא הערך שבתא שלהם והvalue במילון יהיה רשימה מקושרת של כל האינדקסים שחולקים את הערך הזה.
עכשיו נסרוק את המילון שלנו ונחלץ את כל הערכים, ניצור להם קבוצות בשביל הUF וניצור טבלת hash חדשה שלכל ערך תצביע לשורש של העץ UF המתאים.

get(i) - יהיה לנו מצביע לצומת שבו האינדקס הi יושב, נטפס עד השורש (זמן לוגריתמי) ונראה מה רשום בשורש לגבי הערך של הקבוצה.

change(x,y) - בעזרת טבלת הhash שאנחנו מתחזקים נקבל את שורשי עצי הUF שמתאימים לערכים x,y, אם מדובר באותו השורש אז נעצור. אחרת נעשה union ל2 השורשים ובשורש החדש נאמר שהוא מתאים לערך y (זמן קבוע), נעדכן בטבלת הhash שתצביע לשורש החדש ונמחק את x מטבלת הhash כי אין יותר ערך כזה בADT. יוצא סהכ אפילו זמן קבוע בתוחלת (ולא לוגריתמי כמו שביקשו)."
69223,תשובה ל: 2020BB שאלה 6,אתה יכול להעלות את התמונה שוב פעם? היא לא עלתה טוב.
69236,תשובה ל: 2020BB שאלה 6,אמור לפעול עכשיו
73059,תשובה ל: 2020BB שאלה 6,היה אפשר לפתור את זה עם טבלת האש לפי ערכים ובכל ערך עץ AVL של האינדקסים המתאימים? ואז פשוט לבצע במידת הצורך פעולת meld של שני עצי AVL בchange?
73068,תשובה ל: 2020BB שאלה 6,"אני חושבת שזה יכול להיות בעייתי
אם למשל יש לך כמות אינדקסים לינארית בערך מסויים אז האתחול של העץ יעלה O(nlogn)"
73085,תשובה ל: 2020BB שאלה 6,אבל האינדקסים ממוינים אז אפשר לבנות את העץ בזמן לינארי
73102,תשובה ל: 2020BB שאלה 6,אם יש טבלת האש של הערכים ובכל ערך עץ AVL של אינדקסים איך עושים get לפי אינדקס?
82081,תשובה ל: 2020BB שאלה 6,"מדוע כ-Value במילון היינו צריכים לשמור רשימה מקושרת של כלל האינדקסים אשר חולקים את הערך המשותף?
האם יכלנו באותו אופן שהערך במילון יצביע אל הנציג של קבוצת האינדקסים ובעצם בפעולת ה-INIT היינו עושים את הפעולות שתיארת לעיל
אך אם לא קיים הערך בתא המילון: נבצע Make-Set לאינדקס התא אשר הנציג שלה הוא עצמו ונשמור אותו כמצביע למפתח במילון, ובנוסף נוכל לתחזק לכל איבר שניצור באמצעות Make-Set שדה ששמו currentValue שבו ישמר הערך של התא במערך.
במידה וכן קיים- היינו ניגשים למפתח במילון ובאמצעות המצביע היינו מבצעים ראשית Make-Set לאינדקס התא ואז UNION עם הנציג.
בנוסף, מדוע בהינתן המבנה נתונים Union-Find שנוכל לסמנו כ-U פשוט נוכל לבצע על פי ההסבר לעיל U.find(i).currentValue ואז בעצם זהו המימוש של get.
האם המימוש הנ''ל תקין? אני מפספס משהו? תודה מראש"
82225,תשובה ל: 2020BB שאלה 6,"היי פלג,
אני חושבת בget אתה צריך ללכת בהכרח לשורש של הקבוצה כי רק שם אתה מתחייב שהערך הוא הנכון.
לגבי הinit , אם הבנתי נכון, אז עשיתי כמוך, אז אשמח לשמוע גם האם זה תקין :)"
82228,תשובה ל: 2020BB שאלה 6,כשאת מתכוונת לשורש הקבוצה את מתכוונת לנציג? אם כן קריאה ל-find של האיבר כלשהו מניבה את הנציג של הקבוצה אליה הוא שייך.
82241,תשובה ל: 2020BB שאלה 6,אה כן אוקי אז גם כאן עשינו אותו הדבר. אז מצטרפת לשאלה שלך:)
69146,2016BB שאלה 6,.
69147,תשובה ל: 2016BB שאלה 6,"בבירור מהניסוח של השאלה צריך טבלת האש שמצביעה למשהו בסגנון ערימה כאשר המפתח הוא כמות המופעים של האיבר (הדבר ההגיוני הוא ערימת מינימום כדי שמחקית מינימום תמחק את האיבר הכי פחות שכיח)
נראה שההבחנה הקריטית בשאלה היא שהמפתחות משתנים מאוד לאט (מתחילים בערך 1 ואז או שהם נזרקים או שהם גדלים ב1).

לכן הפתרון יראה ככה -
נשמור רשימה מקושרת *ממויינת לפי כמות המופעים*. טבלת ההאש תפנה כל דף לצומת המתאים לו ברשימה המקושרת.
נניח שהזכרון מלא (כשהוא לא מלא אז זה קל). כאשר יש פנייה לדף כלשהו, נחפש אותו בטבלת האש. אם לא קיים אז אנחנו רוצים למחוק את הדף הראשון ברשימה המקושרת (מינימום) והלכניס במקומו את הדף שהרגע קראו לו ולתת לו מפתח של 1 (כי זאת הקריאה הראשונה אליו). אם הוא כן קיים בטבלת ההאש אז נלך לצומת שמתאים לו. נניח ובצומת רשום שיש לדף מפתח x (כלומר מאז שהוא בcache הוא נקרא x פעמים). נרצה לשנות את המפתח לx+1 ולקדם אותו קדימה ברשימה המקושרת במידת הצורך. יש פה מקרה רגיש ובו יש כמה צמתים רצופים ברשימה המקושרת עם מפתח x ואז להגיע לסוף הרצף לוקח זמן. פתרון פשוט לבעיה הזאת יהיה לחשוב על הרשימה המקושרת כרשימה מקושרת (לפי ערך) של רשימות מקושרות (עם אותו הערך), מוסיף ציור:"
69148,תשובה ל: 2016BB שאלה 6,.
69152,2017AB שאלה 12,.
69153,תשובה ל: 2017AB שאלה 12,"אם תוחלת מספר ההתנגשויות היא רבע סימן שבכדי שתהיה התנגשות אז צריך לחרוג ביותר מפי 4 מהתוחלת. מרקוב אומר שההסתברות לכך היא לכל היותר רבע. לכן ההסתברות שלא יהיו התנגשויות היא לפחות 3/4. לכן סהכ תוחלת כמות הנסיונות היא 4/3

P(There is a collision) = P(|col|>=1)<=P(|col|>=4*E[|col|]<=1/4
P(success) = P(There is no collision) >= 1-1/4= 3/4"
69156,2015AA שאלה 3,.
69157,תשובה ל: 2015AA שאלה 3,"מדובר פה בperfect hash שבונים כמו בשיעור בשתי רמות.

רוצים שסך הזכרון של כל המערכים שיוקצו (הראשי ומהשניים) יהיה לכל היותר 100n (וכמו שראיתם בשיעור זה יוצא פחות מ10n). עכשיו השאלה היא איך הפונקצייה שלנו תחזיר מספר בין 1 ל 100n ולא סתם מצביע לתא במערך בשבה השנייה. כדי לעשות את זה היינו רוצים ""לשרשר"" את כל המערכים בשכבה השנייה ולהחזיר את האינדקס ב""מערך המשורשר"".

דרך אחת לעשות את זה היא בכל תא במערך הראשי לזכור את גודל המערך שהוא מצביע עליו ואז לקחת prefix sums כדי שנדע מה המיקום של המערך המשני שהוא מצביע עליו במערך המשורשר. ככה אנחנו משתמשים בזכרון לינארי (שומרים את המבנה של ה2 שכבות) ובזמן קבוע יכולים להחזיר את המיפוי של כל מפתח לאינדקס בין 1 ל100n."
71218,תשובה ל: 2015AA שאלה 3,הבנייה של הperfect hash שראינו בהרצאה הייתה כשבתחום היו n איברים. התחום של h במקרה הזה הוא כל U ואנחנו לא יודעים מה מספר האיברים שם. איך אנחנו יודעים שסך גדלי הטבלאות שאנו צריכים לperfect hash הוא לינארי בn?
71225,תשובה ל: 2015AA שאלה 3,גם כאן התחום בגודל n (מצטמצים לD)
69158,2015AA שאלה 4 סעיף ג,
69159,תשובה ל: 2015AA שאלה 4 סעיף ג,"יש כאן מקום לבלבול בשאלה - ככל הנראה הבוחנים רצו לדבר על חסמי אמורטייזד במונחים של m (כמות הפעולות שבוצעו על מבנה הנתונים) אבל בהרבה מקרים דווקא מעדיפים לדבר על אמורטייזד במונחים של n (כמות האיברים המקסימלית שיש במבנה הנתונים ברגע נתון). ננסה ב2 הדרכים:

במונחים של n -
בגלל העניין של צמתים שמסומנים כמחוקים אז ייתכן שיש לנו מלא צמתים מסומנים ורק מעט איברים במבנה הנתונים. ננצל את העובדה הזאת כדי לתת חסם תחתון לאמורטייזד.
ניצור ערימה עם 2 בחזקת n איברים (פחות אחד) ככה שיתאכסנו בn עצים ונדאג שכל הצמתים פרט לשורשים יהיו מסומנים (ונדאג שלאורך כל הדרך יש רק O(n) צמתים לא מסומנים, תרגיל לא קשה הוא להציג את בנייה כזאת באינדוקציה).
עכשיו כשיצרנו את הערימה הזאת, נוכל לבצע לסירוגין 2 הכנסות של מספרים קטנים ואז 2 מחיקות מינימום ונחזור כל פעם למצב ההתחלתי. נשים לב שארבעת הפעולות הללו עולות לנו סהכ Omege(n) ולכן הזמן אמורטייזד של insert או של deletemin חייב להיות Omega(n).
לכן ממה שאמרנו למעלה, אפשר למשל לטעון זמני אמורטייזד של O(1) להכנסה, O(1) להורדת מפתח, O(1) ל deleteNonRoot ו O(n) לdeleteMin ולהיות מרוצים מהפתרון (הפוטנציאל - מספר העצים).

במונחים של m -
ניתן להגדיר את פונקציית הפוטנציאל להיות מספר העצים ועוד logm כפול מספר הצמתים המסומנים. זמן האמורטייזד של insert הינו O(1), זמן האמורטייזד של deleteNonRoot,decKey הינו O(logm) וזמן האמורטייזד של מחיקת מינימום יהיה O(logm):
הכנסה: נובע מההוכחה של מונה בינארי (ומכך שהחלק בפוטנציאל שסופר צמתים מסומנים לא השתנה).
deleteNonRoot: זה קורה בזמן קבוע ומגדיל את הפוטנציאל ב logm
decKey: זה שווה ל deleteNonRoot+insert שניתחנו אותם כבר.
deleteMin: נחלק את המחיקה ל2 שלבים. השלב הראשון הוא המחיקות הרקורסיביות של צמתים מסומנים והשלב השני הוא ה successive linking.
שלב ראשון - נשים לב שאם ביצענו x מחיקות של שורשים מסומנים אז זאת גם העלות של השלב. בנוסף הרכיב בפוטנציאל שמתאר את כמות הצמתים המסומנים ירד בx*logm. מה שכן, התווספו עוד המון עצים וזה הגדיל את הפוטנציאל. כמה עצים יכלו להצטרף? נשים לב שלכל צומת יש לכל היותר logm בנים ולכן כל שורש שמחקנו יכל להוסיף לכל היותר logm עצים חדשים. לכן יוצא שזמן האמוטייזד לשלב הזה הוא קבוע.
שלב שני - אנחנו עם T_1 עצים ועכשיו אנחנו עושים successive linking שבסופם נהיה עם O(logm) עצים. לכן העלות תהיה O(T_1+logm) והירידה בפוטנציאל תהיה לפחות T_1-logm, כלומר הזמן אמורטייזד לשלב הזה הוא O(logm) (בדיוק אותו הניתוח מהכיתה לערימות עצילות)."
82459,תשובה ל: 2015AA שאלה 4 סעיף ג,"לא הבנתי בניתוח לפי n, איך אפשר להציג מקרה ספציפי של רצף פעולות, ולפיו לנתח אמורטייז. אמורטייז לא צריך להיות חסם על סדרת פעולות כללית?"
69166,"2018BA שאלה 4 סעיפים ב,ג",.
69168,"תשובה ל: 2018BA שאלה 4 סעיפים ב,ג","ג- W̶C̶ ̶=̶ ̶O̶(̶i̶+̶d̶)̶ ̶ תיקון : WC=O(d)
בתהחלה אנחנו מצביעים pointer = i.
מתחילים לסרוק את רשימת המחוקים, כל פעם שרואים תא x מחוק שמקיים x<= pointer אז עושים pointer++.
בסוף מחזירים את התא במיקום הPointer.

ד- זמן האמורטייזד יהיה n^2/3 עבור delete ו n^1/3 עבור retrieve (חשוב לנתח את שניהם ולא לחוד).

יש כמה דברים לטפל בהם -
הגדלה של גודל המערך פי קבוע
הקטנה של גודל המערך פי קבוע
מחיקת האיברים שסומנו כמחוקים אם יש כבר n^1/3 כאלה.

בכדי לטפל ב2 הבעיות הראשונות נכניס לבנק בכל פעולה 10 מטבעות שהתפקיד שלהם הוא לשלם בבוא העת על הגדלה/הקטנה של המערך פי קבוע.
בשביל לטפל בבעיה השלישית, בכל פעולת מחיקה נכניס לבנק n^2/3 מטבעות שהמטרה שלהם תהיה לשלם על הסרת האיברים מהמערך כשיהיה צריך. (כשתגיע פעולה שגורמת לבעיה השלישית אז היו כבר לפחות n^1/3 מחיקות שאפשרו לנו לאגור n^1/3 * n^2/3=n מטבעות שיכסו את הסיבוכיות).
בנוסף, בכל פעולת הכנסה/מחיקה נכניס לבנק n^1/3 מטבעות שישולמו מיידית כדי לכסות על העלות שלהם (במידה ולא קרתה אחת מ3 הפעולות המיוחדות אז הסיבוכיות תהיה O(n^1/3))."
70432,"תשובה ל: 2018BA שאלה 4 סעיפים ב,ג",למה תחילה נכניס 10 מטבעות בשביל לשלם על ההגדלה\הקטנה? ומה למה צריך להכניס בכל מחיקה או הכנסה n^1/3 שישולמו מיידית?
70436,"תשובה ל: 2018BA שאלה 4 סעיפים ב,ג","10 זה סתם הגזמה. ראיתם בשיעור את המימוש של מערך דינאמי. הספיק לשים 3 מטבעות כדי לטפל בו.

לגבי השאלה השנייה שלך - כי זה הcost של הפעולות ואני לא רוצה שירד לי מאזן הבנק."
71327,"תשובה ל: 2018BA שאלה 4 סעיפים ב,ג","היי,
אשמח לקבל כיוון להוכחת חסמים amortized בסעיף ה'.
אני מבינה שניתן לפתור בעזרת עץ AVL עם שדה size באופן הבא: ניתן להכניס לע. את כל האינדקסים המחוקים, ובפעולת retrieve נוכל למצוא את האיבר ה-i בעץ בlogn (אם הוא לא נמצא אז נוכל להכניס אותו, למצוא את ה predecessor שלו ואז למחוק אותו), ואז נוכל להחזיר את הערך במערך באינדקס של הסכום בין הrank של הצומת שמצאנו ו-i. בניתוח WC נקבל logn. כיצד ננתח amortized?
באופן כללי אשמח לראות כיצד נראה פתרון תקין לסעיף הזה.
תודה!"
71341,"תשובה ל: 2018BA שאלה 4 סעיפים ב,ג",יכולה לצרף תמונה של הסעיף?
71359,"תשובה ל: 2018BA שאלה 4 סעיפים ב,ג","מתנצלת, לא שמתי לב שהוא לא צורף יחד עם השאלה המקורית"
71484,"תשובה ל: 2018BA שאלה 4 סעיפים ב,ג","כמו שאמרת, נחליף את הרשימה המקושרת בעץ AVL עם שדה size.

חיפוש של האיבר באינדקס i - ניתן לגלות את האינדקס של האיבר הזה במערך על ידי הסתכלות על עץ האינדקסים המחוקים. האלגוריתם הוא חיפוש סטנדרטי בעץ המחוקים שמתחיל בשורש ויורד ימינה/שמאלה (בהסתמכות על השדה size) עד שמגלים את האינדקס הרצוי.
מחיקה - נסמן את התא במערך כמחוק ונבצע הכנסה של האינדקס הזה לעץ. בנוסף, אם נהיו יותר מידי מחיקות אז כמו שדרשו נאתחל מחדש את מבנה הנתונים.

זמן הWC של חיפוש הפך ל logn וזמן הWC של מחיקה נשאר אותו דבר כי עדיין לפעמים קוראת הפעולה הלינארית.
מבחינת אמורטייזד: מחיקה n^2/3, חיפוש logn והכנסה זמן קבוע. הניתוח שרשמתי למעלה לא משתנה, פרט לזה שלחיפוש צריך לשים רק logn מטבעות כי הוא עולה logn הפעם ולא O(d)."
69220,2017BB שאלה 3,היי :) אשמח לעזרה בשני הסעיפים הבאים: 
69235,תשובה ל: 2017BB שאלה 3,"סעיף ב - מיזוג של מערכים מאורכים n,m עולה n+m, לכן: (העקרון הוא למזג מערכים כמה שיותר בגדלים זהים)
נמזג את המערכים באורך 1 ו 2 ונקבל מערך מאורך 3 בעלות של 3
נמזג את המערכים באורך 3 ו 4 ונקבל מערך מאורך 7 בעלות של 7
נמזג את המערכים באורך 7 ו 8 ונקבל מערך מאורך 15 בעלות של 15
.....
נמזג את המערכים באורך שתיים בחזקת i פחות אחד ו 2 בחזקת i ונקבל מערך מאורך שתיים בחזקת i+1 פחות אחד בעלות של שתיים בחזקת i+1 פחות אחד

אם נסכום את העסק אז מקבלים עלות של סדרה הנדסית שנסכמת ל n.

סעיף ג - (צריך להניח שאנחנו במודל ההשוואות)
נניח בשלילה שיש אלגוריתם ALG שפותר את הבעיה ב o(nlogn), נציג אלגוריתם שפותר את בעית המיון ב o(nlogn) בסתירה.
יהיה מערך A שצריך למיין. נחלק אותו ל n/logn תתי מערכים באורך logn.
נמיין כל אחד מתתי המערכים, העלות של מיון תת מערך בודד היא logn * loglogn, וסהכ עבור n/logn המערכים זה עולה לנו n * loglogn.
נפעיל כעת את ALG על תתי המערכים הממויינים ונקבל מערך ממויין.
סהכ עשינו nloglogn + o(nlogn) השוואות, שזה o(nlogn) השוואות, בסתירה."
69291,תשובה ל: 2017BB שאלה 3,"תודה :)
איך עושים את החיבור (nloglogn + o(nlogn?
זה לא דווקא אמור לצאת nloglogn?
ברור שnlogn גדול מnloglogn אבל במשמעות של o זה לא מתהפך?"
69407,תשובה ל: 2017BB שאלה 3,"o(nlogn) זה כל פונקציה שזניחה לnlogn, וחיבור פונקציות סיבוכיות נותן את המקסימום מביניהן - מכיוון ששתיהן זניחות לnlogn גם הסכום שלהן. 

תאורטית אפשר שזה גם יהיה איזושהי פונקציה שזניחה לnlogn אבל nloglogn זניחה לה - העיקר הוא לומר שביחד זה עדיין זניח"
69465,תשובה ל: 2017BB שאלה 3,תודה :)
70086,תשובה ל: 2017BB שאלה 3,"בסעיף ב של השאלה מעלה, כדי למצוא את האיברים ב-rank המבוקש, אני ממשיך לאחד את כל המערכים עד שלבסוף קיבלתי מערך ממוין אחד גדול?"
70113,תשובה ל: 2017BB שאלה 3,להבנתי כן.
70117,תשובה ל: 2017BB שאלה 3,כן
69278,דף נוסחאות,"היי, האם יחולק לנו דף הנוסחאות שפרסמתם יחד עם טופס הבחינה?"
69496,תשובה ל: דף נוסחאות,כן
69447,מבחן 2020aa (שכתוב בקובץ מבחנים כ2019aa)שאלה 3ג,"בשאלות שפתרנו בתרגול של hash היה תמיד נתון מערך בגודל n ועליו יצרנו את טבלת ההאש והכנסנו אליה את האיברים, בשאלה הזו זה לא המצב ואני רואה שבפתרון המוצע מתארים לעומק את ההגדלה והכיווץ של המערך בהתאם לכמות האיברים.
אני לא כלכך מבינה איך להתמודד עם שאלה מהסוג הזה ששונה לפי מה שאני מבינה מהשאלות שפתרנו בתרגול.

מצרפת את הקובץ עם הפתרון."
69492,תשובה ל: מבחן 2020aa (שכתוב בקובץ מבחנים כ2019aa)שאלה 3ג,"זאת שאלה מעולה -

ההנחה שעשינו בתרגולים היא הנחה מקלה אבל באמת אפשר לפתור את השאלות בסגנון שהציעו במבחן.
באותו מבחן בטעות שכחו לציין את ההנחה המקלה ולכן בפתרון הרשמי הם הציגו איך מתמודדים עם כמות איברים כללית.
הפתרון הפשוט (שעולה זמן קבוע באמורטייזד) הוא כל פעם שכמות האיברים גדלה פי 2 אז להקצות מערך חדש עם פונקציה חדשה ולהעביר את האיברים מהטבלה הנוכחית לטבלה החדשה.
אם רוצים בכלל לא לפגוע בזמני הריצה (כלומר שזה יוסיף רק זמן קבוע בWC), אז ניתן לעשות דה אמורטיזציה לתהליך. במקום בבאת אחת להקצות טבלה חדשה ולהעתיק אליה את כל איברי הטבלה הנוכחית אפשר לאורך ה n/100 פעולות הקרובות:
1. בפעולה הראשונה להקצות בזמן קבוע מערך גדול פי 2 ולהגריל פונקציה.
2. בכל אחת מהפעולות הבאות נעתיק 1000 (זמן קבוע) איברים מהטבלה הנוכחית לטבלה החדשה.

בסוף ה n/100 פעולות האלה אז הטבלה החדשה מכילה כבר את כל המפתחות ואפשר לעבור להשתמש בה."
69500,2018aa שאלה 1ג,"היי :) יש משהו שאני לא מבינה בפתרון הרשמי של השאלה הבאה: 

בפתרון הזה מניחים שהאיברים שמורים בטבלת HASH בסדר הממוין שלהם? אפשר להניח דבר כזה בכלל? 
כי אני פתרתי את זה אותו דבר אבל השתמשתי במערך עזר בגודל K שבו שמרתי את כל האיברים השונים שמצאתי לאורך הסריקה הראשונית של המערך המקורי. לאחר המעבר הראשוני, מיינתי את מערך העזר בסיבוכיות KLOGK ואז עברתי על המערך הזה איבר איבר, מצאתי את הערך המונה המתאים בטבלת HASH והוספתי למערך החדש הממוין בגודל N.

תודה :) "
69505,תשובה ל: 2018aa שאלה 1ג,המפתחות לא ממויינים בטבלה עצמה. בפתרון המוצע הם סורקים את טבלת הhash ושולפים משם את כל המפתחות השונים ושומרים אותם במערך חדש באורך k וממיינים אותו.
69573,2022 b a שאלה 1א,"היי, אשמח להסבר למה הi המינימלי הוא 3? תודה מראש"
69773,תשובה ל: 2022 b a שאלה 1א,"עבור i=3 אפשר לומר על הpivot (החציון של n/9 האיברים שהם השלישיים בגודלם בתשיעייה שלהם) שהוא גדול מ n/18 איברים שכל אחד מהם גדול מ2 נוספים. כלומר על בטוח הpivot גדול מ 3n/18 מפתחות. באותו אופן ניתן להראות שהpivot קטן מלפחות 7n/18 מפתחות.
לכן במקרה הגרוע ביותר לאחר ה partition על הpivot נמשיך את אלגוריתם הselect על הצד הקטן של המערך, שהוא מגודל לכל היותר 15n/18 (כלומר עלות של T(15n/18)), בנוסף עם הקריאה הרקורסיבית כדי למצוא את הpivot (שהיא T(n/9)), מקבלים את הסיבוכיות הרצויה.

לגבי המקרה של i=2. באותו אופן נקבל שנוסחת הנסיגה היא T(n) = T(n/9)+T(16n/18)+O(n)= T(n/9)+T(8n/9)+O(n). נוסחה כזאת מובילה לזמן ריצה של nlogn (אפשר לראות את זה בקלות מעץ רקורסיה, נובע מכך ש n/9 + 8n/9=n)"
69778,דרישות הגדרה בעת שימוש בטבלת hash,"היי,

בתרגול 12 כאשר פתרנו שאלות בעזרת טבלאות hash, הגדרנו לרוב את הגודל של הטבלה (במונחי O), את סוג הטבלה (למשל chaining), ולעתים את סוג ה-hash (למשל אוניברסלי), ועבור שאלה 3 גם את הפונקציה שממפה בין האובייקט אותו אנחנו רוצים להכניס (שהוא 3-tuple), למפתח שייכנס לטבלה. לעומת זאת, ראיתי למשל בפתרון של שאלה ממבחן, שכנראה היה מספיק להגדיר פונקצייה שהתחום שלה הוא למשל R^3.

השאלה שלי היא האם יש הגדרה לדברים שחייבים להופיע בפתרון שמשתמש בטבלת hash? וכמו כן, האם יש דברים שנניח כדאי לכתוב, אבל לא חייבים?

תודה רבה!"
70116,תשובה ל: דרישות הגדרה בעת שימוש בטבלת hash,כל הדברים שציינת בשורה הראשונה חייבים להופיע בפתרון כדי שהוא יהיה מלא
70193,תשובה ל: דרישות הגדרה בעת שימוש בטבלת hash,"אהלן, עדיין לא לחלוטין ברור לי איך מגדירים את סוג ה-hash ואת הפונקציה שממפה בין האובייקט ובין המיקום בטבלה. יש שאלות Hash שבהן מוגדר שצריך להכניס לטבלה ""איברים"", ללא מידע נוסף - איך אפשר להגדיר ככה פונקציה ולהצדיק שהיא מפזרת את הקלטים בצורה טובה?"
70224,תשובה ל: דרישות הגדרה בעת שימוש בטבלת hash,"זה החלק שהיה בשיעור ולא צריך לחזור עליו.
מבחינתך יש לך מילון *התומך במפתחות שלמים* שעושה הכל בזמן קבוע בתוחלת. רק כשאתה מגדיר את המילון תציין שהוא ממומש על ידי טבלת hash מגודל לינארי במימוש chaining (לגבי המשפחה האוניברסלית - ככה תמיד מממשים אז לא באמת חובה לציין).

מה שכן צריך לפרט עליו זה מה אתה במידה והמפתחות הם לא שלמים, במקרה כזה אתה צריך ""תרגום"" של המפתחות למספרים שלמים."
70005,2021AA שאלה 1א,"שלום, אשמח להסבר על מהות השאלה, מה זה T?

לפי ניסחו השאלה התשובה היא תמיד כן לכל איבר שמגיע. aj וai מספרים שלמים, לכן כפולה שלהם ב2 או 3 זה גם מספר שלם והסכום גם שלם וחזקה בשלישית גם מספר שלם. ולכן תמיד T יהיה מספר שלם. מה השאלה כאן בעצם?

תודה"
70102,תשובה ל: 2021AA שאלה 1א,צריך לבדוק אם קיים אינדקס j כך שהמפתח aj מקיים את התנאי. כלומר לבדוק האם המפתח aj נמצא במבנה הנתונים (במידה והוא חוקי). T נתון מראש.
70107,תשובה ל: 2021AA שאלה 1א,איפה רשום שT נתון מראש? על סמך מה ניתן להניח את זה?
70120,תשובה ל: 2021AA שאלה 1א,"פותרים את המשוואה, מחפשים במילון האם קיים המפתח (T^0.333 - 3a_i)0.5"
70177,מבחן 2019BA שאלה 5,"היי,

לא הבנתי בפתרון לשאלה 5 איך אנחנו מבצעים את ה-deleteVertex באותה סיבוכיות. בפרט, לא הבנתי איך אנחנו מוחקים את המופעים של i מרשימת כל אחד מהשכנים שלו.

אם היינו משתמשים במטריצת שכנויות הדבר ברור, אבל במימוש של רשימת שכנויות אני לא מבין ואשמח להסבר.

הנה הפתרון:

תודה"
70220,תשובה ל: מבחן 2019BA שאלה 5,"הגרף לא מכוון ולכן כל קשת (i,,j) תופיע גם ברשימת השכנויות של i וגם ברשימת השכנויות של j. אפשר אז לשמור מצביעים דו כווניים בין 2 המופעים האלה.
עכשיו כשאתה מוחק את i אז תעבור על רשימת השכנויות שלו ותעזר במצביעים האלה כדי למחוק את המופע של הקשתות אצל השכנים."
70229,תשובה ל: מבחן 2019BA שאלה 5,לא עדיף מטריצת שכנויות כדי להימנע מהמצביעים הדו כיווניים האלה?
70271,תשובה ל: מבחן 2019BA שאלה 5,"הזכרון לא אופטימלי, אנחנו כן מורידים על זה"
70275,תשובה ל: מבחן 2019BA שאלה 5,"הבנתי, סבבה.
רק שאלה כללית בקשר למצביעים בין מבני נתונים (או בין איברים) - כשמשתמשים בזה צריך להסביר איך בדיוק מתחזקים ושומרים את המצביעים או שמספיק להגיד שמשתמשים בזה?"
70441,תשובה ל: מבחן 2019BA שאלה 5,"מספיק להגיד שמשתמשים בזה: ""נתחזק מצביעים דו כווניים בין המופעים של האיבר במבני הנתונים השונים"""
70245,2019AB שאלה 5 סעיף ה,"היי,

בשאלה המצורפת, אני לא מבין למה התשובה היא כן.

כדי למצוא ה-n/200 האיברים הקטנים ביותר (באמצעות partition), צריך ״לשלם״ O(n) שוב ושוב, ולמרות שהמערך המקורי קטן לא הצלחתי לחסום את הפעולה בסיבוכיות amortize קבועה.

יש אפשרות להראות הסבר עם פונקציית פוטנציאל / שיטת בנק?

תודה!!"
70273,תשובה ל: 2019AB שאלה 5 סעיף ה,"שים לב שאחרי חישוב של S, יש לך שקט ל n/200 פעולות הבאות (כלומר שילמת עכשיו O(n) אבל ב n/200 פעולות הבאות תשלם רק O(1)).
לכן אפשר לנתח כך את העלות של סדרת פעולות -
ננתח לחוד את העלות של לענות על שאילתות ואת העלות של חישובי S.
עלות של לענות על שאילתות - O(1) פר שאילתא. סהכ O(n)
העלות של חישובי S - כמו שאמרנו, אם עכשיו שילמתי O(n1) (כאשר n1 זה גודל מבנה הנתונים כרגע) על חישוב S אז ב n1/200 שאילתות הקרובות אין חישוב של S ולכן אני יכול לחשוב על זה כאילו אני ממצע את החישוב שעלה O(n1) על פני n1/200 השאילתות הללו וזה יוצא קבוע (המונח המקצועי לזה הוא ""נחייב"" את החישוב של S ל n1/200 פעולות הבאות). כלומר סהכ כל חישובי S מתמצאים לזמן קבוע על פני כל סדרת השאילתות ולכן סה""כ העלות חישובי S היא לינארית.

שיטת הבנק / פוטנציאל לא נוחות כאן. חישוב ישיר כמו שעשינו יצא הכי נוח."
70286,מבחן 2019AB - שאלה 3א,"היי,
אני לא מבין למה המשפט שמודגש בצהוב נכון.

תודה"
70440,תשובה ל: מבחן 2019AB - שאלה 3א,"מתקיים N = nloglogN
נוכיח ש loglogN = O(loglogn):
בבירור מתקיים N= O(n^2) ולכן logN= O(logn) ולכן גם loglogN = O(loglogn)."
70353,2020ab שאלה 1א,"היי :) 
אני אשמח להבהרה לגבי הטעות הנפוצה הראשונה. הרי שתי הקבוצות נתונות לנו. מה הבעיה לבחור אחת מהן ואותה להכניס לperfect hash? 

אני גם השתמשתי בperfect hash והכנסתי אל כל איברי A לתוך הטבלה ואז עברתי על איברי B ובדקתי אם הם קיימים בטבלה."
70433,תשובה ל: 2020ab שאלה 1א,"לא אמרו שזה לא נכון להשתמש ב perfect hash, זה פשוט מיותר.

מה שרשום בפסקה השנייה בסוגריים הוא ניתוח אלטרנטיבי לאלגוריתם בפסקה הראשונה (שלא משתמש ב perfect hash).
הם אומרים, נניח הכנסנו את A לטבלת hash רגילה (מילון). ראינו בניתוח של perfect hash שאפילו אם גם היינו מכניסים את כל B לתוך אותה טבלה אז כמות ההתנגשויות הייתה O(n) בתוחלת.
עכשיו הם מנתחים את הסיבוכיות של האלגוריתם על ידי זה שהם אומרים שעלות החיפוש של כל איבר בB בתוך הטבלה היא שווה לכמות ההתנגשויות שלו עם איברים בA. לכן הסיבוכיות הכוללת חסומה על ידי כמות ההתנגשויות בטבלה הדמיונית שגם A וגם B בתוכה (ואמרנו שזה O(n)).

הפתרון שלך נכון, רק הייתי נזהר עם הניסוח של ""השתמשתי בperfect hash והכנסתי אל כל איברי A לתוך הטבלה"". הניסוח הוא נאתחל בזמן לינארי perfect hash על איברי A. (הטעות הנפוצה השנייה)"
70981,תשובה ל: 2020ab שאלה 1א,"היי, איך אפשר לנסח נכון התנגשויות שעשויות לקרות אם בחרנו במימוש CHAINING?"
70983,תשובה ל: 2020ab שאלה 1א,"אין צורך בכלל לדבר על התנגושיות.
מבחינתך הכנסת את איברי A למילון ולאחר מכן את עוברת על איברי B ובודקת האם הם מופיעים במילון. מה קורה מאחורי הקלעים כשאת משתמשת במילון לא אמור להיות לך אכפת.

הסיבה היחידה לציין מה המימוש של המילון היא בשביל שבניתוח סיבוכיות תוכלי לומר שכל הפעולות רצות בזמן קבוע בתוחלת"
70354,שאלות חזרה למבחן,"שעת קבלה דני, 5.2.2023 - הקלטה. מצורף  לוח

תרגול חזרה דני, 6.2.2023 - הקלטה.  מצורף לוח

שעת קבלה דני, 28.2.2023 - הקלטה. מצורף לוח

שעת קבלה דני, 2.3.2023 - הקלטה. מצורף לוח

תרגול חזרה ישן - הקלטה

מוזמנים לצרף פה שאלות (עם תמונה) וגם להצביע מה אתם הכי רוצים שייפתר בתרגולי החזרה (להגיב על שאלה שהעלו ""רוצה"").

נשתדל לבחור שאלות מבין אלו שיעלו כאן."
70408,תשובה ל: שאלות חזרה למבחן,"אשמח אם יהיה אפשר לפתור את שאלה 4 במבחן 2018BA
תודה!!"
70596,תשובה ל: שאלות חזרה למבחן,אשמח לפתרון השאלה הבאה- ממבחן 2021 סמסטר א מועד ב. תודה!
70811,תשובה ל: שאלות חזרה למבחן,רוצה את מה ששרון שלחה
70888,תשובה ל: שאלות חזרה למבחן,"אשמח אם יהיה אפשר לפתור את 2022AB שאלה 4, שני הסעיפים."
71216,תשובה ל: שאלות חזרה למבחן,
71241,תשובה ל: שאלות חזרה למבחן,רוצה את מה ששרון שלחה (2018BA שאלה 4)
71416,תשובה ל: שאלות חזרה למבחן,היי אני אשמח אם נוכל לפתור את שאלה 4 ממבחן 2021aa:[שאלה 4 מבחן 2021 סמסטר א מועד א]
71564,תשובה ל: שאלות חזרה למבחן,מצטרפת לבקשות של גיא ועינת.
71884,תשובה ל: שאלות חזרה למבחן,מצטרפת ןבקשה של אור לוי
81429,תשובה ל: שאלות חזרה למבחן,אשמח אם תוכלו בבקשה לעלות את התרגול חזרה והשעת קבלה של דני בשנית שכן במידה ונכנסים לקישור כתוב שההקלטה לא נמצאת. תודה מראש!
82032,תשובה ל: שאלות חזרה למבחן,יש אפשרות להעלות את ההקלטה מה2.3?
82046,תשובה ל: שאלות חזרה למבחן,בוצע
70421,2018BA שאלה 3ד,אשמח להבין מה הפתרון למימוש הרביעי בשאלה זו. חשבתי אולי להשתמש בערימה בינארית אבל אני לא בטוח איך להוכיח שהיא עומדת בדרישות הסיבוכיות.
70422,תשובה ל: 2018BA שאלה 3ד,קיים שרשור על השאלה הזאת
70429,2017AA שאלה 3א,האם בשאלה כזו הייתי יכול להשתמש בזה שראינו בכיתה שאתחול של וקטור עם אפסים לוקח O(1) ואז מאחר שמשנים את הערכים רק  m פעמים הסיבוכיות תהיה O(m) במקום O(m+n)?
70438,תשובה ל: 2017AA שאלה 3א,"כן.
בכל מקרה יהיה O(n) נוסף בסיבוכיות כי ביקשו לכל מספר בין 1 ל n להחזיר תשובה (יכול להיות גם 0)"
70451,מבחן 2019BB שאלה 8,"היי, יש לי כמה שאלות על שאלה 8 ממבחן 2019BB:

1. איך מתבצעת פעולת ה-delete עם המימוש הזה? הרי בהסבר כתוב שהפעולה צריכה לקבל מצביע לאובייקט. מה האובייקט פה?

2. אם יש לי כפילויות באחד העצים, למשל יש לי את שני הקטעים [1,2] ו-[1,3] איך מתייחסים לזה?

3. בפתרון אומרים שעבור containCount(x) נשתמש בפעולת -rank, אם x לא נמצא במבנה, אז האם בכלל פעולת ה-rank חוקית? אם כן, מה היא אמורה להחזיר?

4. בנוסף אשמח להסבר איך ניתן לעשות את זה עם עץ דרגות אחד לפי מה שרשום בפתרון. 

תודה"
71004,תשובה ל: מבחן 2019BB שאלה 8,"1. תקבל מצביע לאחד הnode של קצות הקטע, אתה צריך לשמור מצביעים דו כווניים כדי שתוכל להגיע גם לnode של הקצה השני.
2. אתה תקבל מצביע לnode שקשור לקטע שאותו מוחקים (בפרט המצביע הדו כווני כן יגיע לקצה השני של הקטע)
3. חוקי, ההגדרה של rank היא כמות המפתחות שקטנה או שווים לך, אתה לא חייב להיות שייך למבנה הנתונים.
ד.נשמור בעץ גם את כל הקצוות השמאליים וגם את כל הקצוות הימניים, כאשר יהיו לנו מצביעים דו כווניים בין 2 קצוות מתאימים. בשביל לממש את containCount נהיה צריכים שדה בכל צומת שאומר כמה קצוות ימניים יש לו בתת העץ, כנ""ל גם עבור כמה קצוות שמאליים. בעזרת 2 השדות האלו אפשר לחשב את הranks שהיו לך אם כן היית  משתמש ב2 עצים."
71629,תשובה ל: מבחן 2019BB שאלה 8,"אז באופן כללי - אם אני יודעת שאיבר x לא נמצא בעץ AVL ואני רוצה עדיין למצוא את כמות המפתחות שקטנים/שווים לו, אני יכולה להגיד שנעשה עליו את הפעולה TreeRank(x) ? פשוט לפי מה שלמדנו בהרצאה על הנושא, הפעולה rank(x) מתחילה ב-x (מקבלת מצביע אליו) ואם אם נבצע חיפוש אז נגיע רק לעוקב/לקודם שלו."
71827,תשובה ל: מבחן 2019BB שאלה 8,"מבחינתי אפשר.
עוד אפשרות היא להכניס את x, לאחר מכן לעשות treeRank ואז למחוק את x"
70490,מבחן 2019BA שאלה 6א,"שלום, אשמח להסבר יותר מפורט על התשובה בסעיף א':

למה זה בהכרח סופר את כמות ההחלפות שהיו? ניסיתי לצייר דוגמאות אבל עדיין לא הצלחתי לשכנע את עצמי. תודה רבה!"
70686,תשובה ל: מבחן 2019BA שאלה 6א,"ניקח למשל מערך ממוין, אם מכניסים את האיברים שלו בזה אחר זה לעץ דרגות, תמיד יתקיים ש-n-TreeRank(x) יהיה 0, כי אנחנו מכניסים את האיברים לפי הrank שלהם (הראשון שמוכנס הוא מ-rank 1, השני שמוכנס מrank 2 וכן הלאה).

עכשיו ניקח מערך ממויין עד כדי החלפה אחת, נגיד שכל האיברים נמצאים במקום הנכון מלבד האינדקס ה-i והאינדקס הj שהתחלפו (נגיד שi קטן מ-j). כשאנחנו מגיעים לאינדקס ה-i, אנחנו מוסיפים לקאונטר את i + 1 - j (כי הכנסנו עד כה i+1 איברים והמקום 'הנכון' של האיבר הi הוא בעצם j). כשאנחנו מגיעים מתישהו אחרי זה לאינדקס ה-j, אנחנו מוסיפים לקאונטר את j + 1 - i מאותם שיקולים כמו קודם
 סה""כ אם נסכום נקבל 2 - ובאמת שני אינדקסים התחלפו ביניהם.

האינטואיציה היא כשאנחנו מחברים את הערכים המחושבים עבור שני אינדקסים שעברו החלפה, ה-rank שמחושב עבור השמאלי יהיה ה-n שמחושב עבור הימני ולהפך, אז שני הערכים האלה יתקזזו ונישאר רק עם ה+1 שאנחנו מוסיפים לכל אחד מהאינדקסים (כי אנחנו סופרים כמה הכנסנו עד לאינדקס הi כולל), ונישאר תמיד עם 2"
70986,תשובה ל: מבחן 2019BA שאלה 6א,"עילי - הסיבה שהאלגוריתם נכון היא ש n-treeRank(x) (זה מחושב בדיוק כאשר הכנסנו את x) בדיוק סופר לנו בכמה חילופים x נמצא בהם x הוא האיבר בעל האינדקס הגדול יותר.

אמרי - הדוגמה שלך בפסקה השנייה שגויה, אם i וj יושבים במקומות הפוכים אז כמות החילופים היא j-i ולא 2. בדוגמה שלך כשאתה מכניס את j לעץ את עדיין צריך להוסיף 0 לסכום כי j המקסימלי."
70583,2020AA שאלה 4ג,"צירפתי גם את תנאי סעיף ב׳ אבל אני שואלת על סעיף ג׳- 

לא ברור לי למה צריך לשמור במערך עזר את כל הישרים, זה לא חישוב מיותר? אי אפשר לקחת 7 נציגים של זוגות נקודות Pi, Pi+1 ולחשב רק עבורם את הישר במקום עבור כל הn-1 זוגות?

כלומר עדיין להגדיר את היחס סדר ולעשות כל מה שכתוב בפתרון, רק לבצע את הselect על הנקודות במקום על הישרים."
70997,תשובה ל: 2020AA שאלה 4ג,כדי לעשות select צריך מערך
71019,תשובה ל: 2020AA שאלה 4ג,"כן, הכוונה למערך של הנקודות"
71107,תשובה ל: 2020AA שאלה 4ג,"לא סגור שהבנתי את השאלה.
את יודעת שיהיו לך ישרים זהים לא נקודות זהות (אנחנו יוצרים ישר באמצעות 2 נקודות)"
71114,תשובה ל: 2020AA שאלה 4ג,"נכון
למה אי אפשר לחשב נקודתית את הישרים לנקודות שנמצא בselect במקום לחשב את הישרים של כל הנקודות?"
71124,תשובה ל: 2020AA שאלה 4ג,עדיין לא חושב שמבין. אם את יכולה אז בבקשה תעלי פתרון שלדעתך צריך לקבל ניקוד מלא ואומר מה לא נכון בו
70585,2019 ab שאלה 10,"היי, אשמח להסביר לגבי הסיבוכיות amortized - לא הבנתי את ההסבר שנתנו פה:"
70872,תשובה ל: 2019 ab שאלה 10,"לא הבנתי את ההסבר שלהם אבל נראה לי בשיטת הבנק אפשר שכל הכנסה זולה (=insert בלי לינקים, כל עוד #fresh קטן שווה ממאה) שמה מטבע אחד על הצומת שמכניסים
בפעולה יקרה של successive linking כל אחד מהצמתים האלה מגיע ללינק עם מטבע עליו, משתמשים באחד מהשניים כדי לשלם על הלינק, ואז על העץ שנוצר מהלינק יש מטבע
אפשר להראות ככה באינדוקציה שתמיד מתקיים שכל עץ מגיע ללינק כשכבר יש עליו מטבע, ותוצאת הלינק היא עץ שעדיין יש עליו מטבע, קנינו כמות קבועה של מטבעות בכל הכנסה זולה אז זה O(1)"
70946,תשובה ל: 2019 ab שאלה 10,תודה אמרי
70992,תשובה ל: 2019 ab שאלה 10,"היה אפשר להשתמש גם בנימוק לפיו מכיוון שאנחנו מבצעים רק הכנסות (ואין פיצולים שיכולים להגרם ממחיקות ולהשפיע על מספר העצים) אז מספר העצים המקסימלי האפשרי היה n ובסוף התהליך נשאר לכל הפחות עץ אחד - וכל פעולת לינק מקטינה את כמות העצים ב-1, לכן בוצעו לכל היותר n פעולות link?"
71011,תשובה ל: 2019 ab שאלה 10,"כן, צריך גם להוסיף לנימוק למה זמן הריצה באמת פרופורציוני לכמות הלינקים"
70591,2018BB שאלה 2,"מצורפת השאלה בצירוף סעיפים ג'-ה'.

תחילה, לא הבנתי כיצד לגשת להגדרת הפעולה- אשמח להסבר על הפעולה.

ושנית- כיצד לחשב את עלות ה-amortized בסעיף 5?"
70972,תשובה ל: 2018BB שאלה 2,"אפשר לצרף את כל הניסוח של השאלה?

סעיף 5 -
צריך להציג את זמני האמורטייזד של כל הפעולות, נראה זמני אמורטייזד של שורש n לפעוולות המעניינות וזמן אמורטייזד קבוע עבור item:
נוכיח באמצעות שיטת הבנק:
item - נשים 10 מטבעות, נשלם אחד מהם על הפעולה.
delete - נשים O(n^0.5) מטבעות ונשלם איתם על הפעולה.
insertAfter - נשים 3 מטבעות בשביל המקרה שצריך להקצות מערך חדש גדול פי 2 (זה סוג ראשון של מטבעות), בנוסף נשים O(n^0.5) מטבעות למקרה שבלוק התמלא וצריך עכשיו לארגן מחדש את האיברים של כל הבלוקים על פני המערך (זה סוג שני של מטבעות), נשים בנוסף עוד O(n^0.5) מטבעות כדי לשלם על הפעולה עצמה במידה ולא קרה שום דבר שלוקח זמן לינארי.

נכונות: (למה מאזן הבנק אי שלילי? )
נניח ועכשיו עשינו פעולה שעולה זמן לינארי -
1. אם הפעולה היא הקצאה של מערך גדול פי 2, אז המטבעות מהסוג הראשון של Insert יממנו את זה.
2.אם הפעולה היא פיזור אחיד של איברי הבלוקים על אותו המערך, אז המטבעות מהסוג השני יממנו את זה (נשים לב שלאחר פיזור מחדש, בגלל שיש לכל היותר m/2 איברים במערך אז כל בלוק הוא לכל היותר חצי מלא. לכן כדי שבלוק יתמלא, היו צריכות לקרות עוד 0.5m^0.5 הכנסות שאוגרות לנו מספיק מטבעות מסוג 2 כדי לשלם על הפיזור הבא)"
70658,2021 AB שאלה 1ב,"היי, אשמח להסבר למה מה שממורקר נובע מסעיף א? זה לא ברור לי

תודה מראש!"
70993,תשובה ל: 2021 AB שאלה 1ב,"בסעיף ב מראים שחובה לפחות nlogn השוואות.
בסעיף א רואים שלכל k שהוא O(n/logn) אז ניתן לפתור את הבעיה בלכל היותר nlogn השוואות, כלומר זהה לחסם התחתון של סעיף ב (משמע הדוק)"
71316,תשובה ל: 2021 AB שאלה 1ב,
71330,תשובה ל: 2021 AB שאלה 1ב,"היי,
אשמח להבין מה לא נכון בפתרון שלי לסעיף א:
נעבור על אברי המערך עם מונה שיאותחל ל-0.
באינדקסים הזוגיים, במידה ואין עליה בין התא במקום הזוגי לזה שאחריו נחליף ביניהם ונעלה את המונה ב-1. אם יש עליה פשוט נעלה את המונה ב-1.
כנ""ל לגבי אינדקסים אי זוגיים.
נעצור אחרי n/k איטרציות.

ניסיתי לשחק עם דוגמאות ולהפריך את זה ולא הצלחתי, אפשר עזרה?
תודה"
71340,תשובה ל: 2021 AB שאלה 1ב,"לא התעמקתי בנכונות של האלגוריתם אבל אם אתה עושה n/k איטרציות אז הסיבוכיות היא n^2/k, לא?"
71349,תשובה ל: 2021 AB שאלה 1ב,אני עושה עבודה בזמן קבוע בכל איטרציה אז זה O(n/k)
71450,תשובה ל: 2021 AB שאלה 1ב,"אה, מדובר בסריקה אחת של המערך?
ב O(n/k) זמן לא תצליח לקרוא אפילו חצי מהמערך ולכן אין סיכוי שתוכל לתת חסם עליון לכמות הזיגזגים במערך"
71472,תשובה ל: 2021 AB שאלה 1ב,"אז נראה לי שלא הבנתי את השאלה, תוכל אולי להסביר לי מה בדיוק מבקשים?
ממה שאני הבנתי, אנחנו מקבלים מערך A בגודל n וערך r, וצריכים לשנות את המערך כך שיהיה r-זיגזג, כלומר שתהיה סדרה עולה של r אינדקסים כך שמאינדקס זוגי לאי זוגי תהיה עליה ומאי זוגי לזוגי תהיה ירידה."
71487,תשובה ל: 2021 AB שאלה 1ב,"אין קשר לזוגיות האינדקסים. דוגמאות למערכי 3 זיגזג:

1,2,3,4,3,2,1,2,3
1,2,1,2
1,1,1,1,1,1,,2,2,2,2,,2,1,1,1,1,1,,2,2,2"
71491,תשובה ל: 2021 AB שאלה 1ב,"אז מה המשמעות של המשפט ""כך שתת המערך A[Ij,Ij+1] עולה אם j זוגי ויורד אחרת""?
מתייחסים פה לזוגיות של האינדקסים בתוך סדרת האינדקסים"
71500,תשובה ל: 2021 AB שאלה 1ב,i_j יכול להיות כל דבר. j בהגדרה הזאת הוא זה שמדברים על הזוגיות שלו
71512,תשובה ל: 2021 AB שאלה 1ב,"סליחה שאני ככה נתקע על זה אבל אני עדיין לא כ""כ מבין..
אתה יכול לתת לי דוגמה למערך שהאלגוריתם שלי לא יצליח להפוך אותו למערך זיגזג?
(דרך אגב, בשאלה כתבו שכל אברי המערך שונים אז איך הדוגמאות שהבאת למעלה נכונות?)"
71819,תשובה ל: 2021 AB שאלה 1ב,"אני עדיין לא מבין את האלגוריתם שלך, אצטרך הסבר חד יותר ודוגמאות של איך הוא רץ על מערכים ופרמטר k=3"
71844,תשובה ל: 2021 AB שאלה 1ב,"דוגמה 1:
נקבל את המערך [1,2,3,4,5,6].
נתחיל לעבור עליו:
איטרציה 1 - נבדוק זוגיות לאינדקס הראשון (0) -> זוגי -> נבדוק האם התא הבא אחריו גדול ממנו (2>1). הוא כן אז נמשיך הלאה.
איטרציה 2 - נבדוק זוגיות לאינדקס השני (1) -> אי-זוגי -> נבדוק האם התא הבא אחריו קטן ממנו (2>3). הוא לא, אז נחליף ביניהם - 3 יעבור לאינדקס 1 ו-2 יעבור לאינדקס 2.
המערך בסוף האיטרציה השניה: [1,3,2,4,5,6] מקיים 3-זיגזג עם האינדקסים 0-2.

דוגמה 2:
נקבל את המערך [5,1,7,9,3].
נתחיל לעבור עליו:
איטרציה 1 - נבדוק זוגיות לאינדקס הראשון (0) -> זוגי -> נבדוק האם התא הבא אחריו גדול ממנו (1>7). הוא לא, אז נחליף ביניהם - 1 יעבור לאינדקס 0 ו-5 יעבור לאינדקס 1.
המערך בסוף האיטרציה הראשונה: [1,5,7,9,3].
איטרציה 2 - נבדוק זוגיות לאינדקס השני (1) -> אי-זוגי -> נבדוק האם התא הבא אחריו קטן ממנו (7<5). הוא לא, אז נחליף ביניהם - 7 יעבור לאינדקס 1 ו-5 יעבור לאינדקס 2.
המערך בסוף האיטרציה השניה: [1,7,5,9,3]. מקיים 3-זיגזג עם האינדקסים 0-2.

יכול להיות שלא הבנתי את השאלה נכון, אשמח להסבר"
71904,תשובה ל: 2021 AB שאלה 1ב,"לפי איך שאני רואה את זה, האלגוריתם עלול לעצור בלי לקרוא את כל המערך. מה קורה אם בהמשך המערך יש עוד הרבה זיגזגים, איך הם נספרים?

או למשל - אם במערך יש n זיגזגים  ורוצים שיהיו רק 2, איך זה קורה?"
71907,תשובה ל: 2021 AB שאלה 1ב,"לא הבנתי את השאלה שלך, למה שזה ישנה מה קורה בהמשך המערך? האלגוריתם דאג לכך שיהיה r-זיגזג.
האלגוריתם אמור לעצור אם הוא מוצא סדרה של r אינדקסים שמקיימים את הדרישה, אז למה שנרצה להמשיך לקרוא את המערך במקרה שהפכנו את המערך למערך r-זיגזג (בלי לקרוא את כל המערך)?"
71945,תשובה ל: 2021 AB שאלה 1ב,"אני חושב שהאי הבנה נובעת משני מקומות, קודם כל שבנתונים של השאלה מוגדר שi0 = 0, ir = n, כלומר האינדקס הראשון והאחרון חייבים לקיים את כלל הזיגזג אז אי אפשר להימנע מסריקה עד הסוף (אם כי בדוגמאות שדני נתן יש דוגמא שלא מקיימת את זה, אז לא בטוח שזה העניין)

דבר שני הדרישה על הזוגיות של האינדקס מתייחסת למיקום במערך [i0, i1, i2...] ולא למיקום במערך A המקורי. הכוונה שבתוך מערך r האינדקסים, יש לך לסירוגין זוג אינדקסים שהוא עלייה מקומית, זוג אינדקסים הבא שהוא ירידה מקומית, וכך הלאה
זו דרך קצת מסובכת לומר שמערך k-זיגזג זה מערך שיש בו k מקסימומים מקומיים, או להגיד שאם תחליק את הפונקציה ותגזור אותה תקבל שהנגזרת מתאפסת בדיוק k פעמים, ושהיא מתחילה מערך חיובי ב-n=0 (שזה כנראה דרך יותר מסובכת להגיד את זה)"
71948,תשובה ל: 2021 AB שאלה 1ב,"*k נקודות קיצון לא כולל הקצוות, לא k מקסימומים מקומיים

כאילו כל המערכים חייבים להיראות אשכרה כמו זיגזג מההתחלה ועד הסוף, זה הופך את השאלה ואת הפתרון ליותר הגיוניים, נגיד בציור של העליות והירידות בערכית עבור K=5:"
71972,תשובה ל: 2021 AB שאלה 1ב,"אם הסיפור הוא שהאינדקס הראשון צריך להיות אפס והאחרון n-1, אפשר פשוט לסיים את המעבר על כל המערך באלגוריתם שלי ועדיין נקבל זיגזג, פשוט בכל סדרה יהיו שני אינדקסים.

אני עדיין לא מבין למה האלגוריתם לא נכון.. אם הוא לא נכון כנראה שיש דוגמה שמפריכה את זה, כלומר דוגמה למערך שהאלגוריתם יקבל ולא יוציא מערך זיגזג. אם יש לך כזו אשמח לראות"
72077,תשובה ל: 2021 AB שאלה 1ב,"אז נראה לי שהשאלה כאן האם צריך שהמערך יהיה בדיוק r-זיגזג עם בדיוק r נקודות קיצון, או שמה שעשית (ליצור מערך עם עוד יותר זיגזגים שבפרט יש בו r זיגזגים) זה בסדר.
מסכים איתך שביחס לניסוח של השאלה מה שעשית הגיוני, אבל יותר סביר שרוצים אלגוריתם שיוצר בדיוק r נקודות קיצון אחרת הבעיה קלה מדי, אתה יכול פשוט לשבור את כל המערך וליצור n זיגזגים בזמן לינארי כמו שעשית, מה גם שזה אומר שלא משנה איזה k מכניסים כפרמטר ל-r התשובה היא אותה תשובה, כי אפשר פשוט לשבור לכדי n זיגזגים בלי להתייחס לr בכלל שזה פתרון מוזר"
72210,תשובה ל: 2021 AB שאלה 1ב,כן רוצים שהמערך יהיה בדיוק r זיגזג
72218,תשובה ל: 2021 AB שאלה 1ב,ודורשים שהאינדקס ה-0 וה-r בסדרה יהיו האינדקסים ה-0 וה-n-1? זאת הסיבה שהאלגוריתם נופל?
72676,תשובה ל: 2021 AB שאלה 1ב,"שאלה ראשונה - כן.

שאלה שנייה - אני חושב"
73028,תשובה ל: 2021 AB שאלה 1ב,"בלי קשר לשרשור הארוך שלמעלה, האם אפשר להרחיב על ניתוח הסיבוכיות בסעיף השני? איך הגענו לnloglogn? האם מדובר בשיטת מיזוג מערכים באמצעות עץ AVL?
תודה"
73037,תשובה ל: 2021 AB שאלה 1ב,"כן, בתרגול 5 הראנו שאפשר למזג k מערכים ממויינים באמצעות עץ AVL שבכל רגע נתון יחזיק את האיברים ש-k האינדקסים שלנו מצביעים עליהם בזמן nlogk
כאן k = logn ולכן סהכ nloglogn
אפשר לעשות את זה גם עם ערימת מינימום באותה סיבוכיות לדעתי (בגלל שאי אפשר להתחמק מה-logn של delete-min)"
73043,תשובה ל: 2021 AB שאלה 1ב,"אם יש לך k מערכים ממוינים וסכום אורכי המערכים הוא n, ניתן להגיע למערך ממוין בסיבוכיות O(nlogk). אפשר לעשות את זה באמצעות ערימת מינימום. (בהתחלה הכנסנו לערימה את האיבר הקטן ביותר מכל מערך(ז""א k איברים) ובכל פעם מבצעים deleteMin מהערימה כדי לקבל את האיבר הבא הקטן ביותר, ומכניסים לערימה את האיבר הבא מהמערך שממנו הוצאנו הרגע איבר. בגלל שבכל שלב יש לנו לכל היותר k איברים בערימה ומבצעים n פעמים מחיקת מינימום, נקבל O(nlogk))
הסעיף השני הוא מקרה פרטי, כאשר k=logn, לכן הסיבוכיות היא O(nloglogn)"
70663,2021 AB שאלה 2,"עשיתי גם פתרון של AVL בסעיף א וHASH בסעיף ב, אבל תחזקתי בצד שדה של SUM וEVENSUM שמתעדכן בכל הכנסה ומחיקה של איבר למבנה. 

ערך SHIFT- שסוכם עדכוני ערך SHIFT מקריאות SHIFT(X).

 ברגע שנקראת הפונקציה מחזירה בהתאם לערך של SHIFT- האם זה גם היה מתקבל? 

מצרפת מה שכתבתי בתקווה שיסביר את הכוונה שלי:

אם הבנתי משהו לא נכון אשמח לדעת, תודה רבה מראש!

[כ]"
70990,תשובה ל: 2021 AB שאלה 2,"הפתרון נכון (יש לך כמה פשלות קטנות, מצרף למטה) , כשכתבנו את השאלה פספסנו שיש פתרון כזה פשוט.

כמה טעויות-
1) אין דבר כזה שדה rank. זאת פעולה שלוקחת logn זמן וניתן לממש אותה רק אם יש לנו שדה size. בכל מקרה לשאלה הזאת אין צורך בכך.
2) צריך לשמור גם את כמות המפתחות בכללי במבנה הנתונים (אם עושים shift אי זוגי אז כל המפתחות הזוגיים והאי זוגיים מתהפכים אז צריך עוד טיפה מידע כדי להיות מסוגלים לחשב את evenSum ואת numEven)"
70714,מבחן 2019AA שאלה 16,"אשמח להסבר מדוע התשובה לסעיף ב' מתקבלת?

לא מתואר בשאלה שנקבל מצביע לאיבר, ולכן לפני כל מחיקה נשלם בכל מקרה O(logn) לטובת החיפוש של האיבר. נגיד שאחרי זה המטבעות ישלמו על פעולה זו(שגם לא הבנתי איך), עדיין נקבל כי כל פעולה תהיה באמורטייז logn.

אני תהיתי לעצמי אולי הכוונה בשאלה זו שאנחנו אכן מקבלים מצביע לאיבר X, אך מצויין מפורשת שX הוא מפתח.

איך אני אמור להבין אם מקבלים מצביע לאיבר או לא?

תודה רבה"
70978,תשובה ל: מבחן 2019AA שאלה 16,"לא מקבלים מצביע, אם מקבלים אז לרוב אנחנו מציינים את זה.

הנימוק שהם רשמו בפתרון הוא מדוייק.
אינטואיטיבית - ""יש פחות מחיקות מהכנסות ולכן ניתן לחייב מחיקה להכנסה"". אם יש יותר מחיקות מהכנסות אז רובן לוקחות זמן קבוע כי אתה מוחק כלום."
71615,תשובה ל: מבחן 2019AA שאלה 16,"רק כדי להבין, זה אומר שבאופן כללי היה אפשר לטעון שבעץ AVL כמו שלמדנו המחיקה היא בamortized O(1) ?

האם ניתן לחייב את פעולות ההכנסה על החיפוש? כדי להגיע להכנסה בO(1) אמורטייז?"
71826,תשובה ל: מבחן 2019AA שאלה 16,"שאלה ראשונה - כן

שאלה שנייה - לא (לא חייבים להיות בכלל חיפושים ואין לך חיפושים שתוכל לחייב אליהם את ההכנסות)"
70732,2020 AA שאלה 2א,"היי, אפשר לומר בקצרה איך לפתור את א? מופיע בקובץ פתרון רק לסעיפים ב-ג ולא יודעת איך לעשות את א, תודה רבה מראש!"
70855,תשובה ל: 2020 AA שאלה 2א,"היי,
ברמת העיקרון לאפשר IncreaseKey בערימת פיבונאצ'י מינימום זה לא אפשרי ב-O(1), כי יכול להיות שנגדיל את ערכו של מפתח כך שכלל הערימה יופר, ובמקרה הגרוע נצטרך לגלגל אותו עד למטה, ואז אי אפשר לממש את זה ב-O(1) אמורטייזד. צריך לשים לב שגם אי אפשר פשוט לתלוש אותו, כי יכול להיות שהוא מפר את כלל הערימה מול כל הילדים שלו (בניגוד למקרה של decrease key שמפר את כלל הערימה, שאז אפשר רק להפר את כלל הערימה מול ההורה שלי ואפשר פשוט לתלוש).

ההגבלה על ה-increasekey שנתונה כאן היא בעצם מגבלה על פעולות ה-heapify שנצטרך אולי לעשות כתוצאה מהincreasekey והפרת כלל הערימה. אם אנחנו יודעים שהrank של צומת שעושים לו increase יכול לעלות מקסימום באחד, אז המקסימום שיכול לקרות זה שהצומת הזה עכשיו גדול יותר מהסקססור שלו (הוא לא יכול להפוך להיות גדול יותר מצמתים נוספים שהיו גדולים ממנו קודם, כי אז ההגבלה לא הייתה מתקיימת).

אם הסקססור הוא לא בן ישיר של הצומת שהגדלנו, מובטח לנו שלא הפרנו את כלל הערימה מול אף אחד מהילדים. אם הוא כן בן ישיר, אפשר פשוט להחליף בין הצומת לסקססור ואז בוודאות כלל הערימה מתקיים. יש לנו מצביע לסקססור ולצומת עצמו אז אפשר לעשות את זה ב-O(1) (לא צריך לחפש את הסקססור בין הילדים או משהו)."
70951,תשובה ל: 2020 AA שאלה 2א,"פסקה ראשונה - זאת השערה שלך לאיך היו ממשים increasekey כללי (ונימקת טוב למה זה לא טוב), אולי יש דרכים אחרות

לגבי 2 הפסקאות האחרונות - בול, תודה אמרי"
70976,תשובה ל: 2020 AA שאלה 2א,הסבר מעולה ממש מוערך! תודה
71075,תשובה ל: 2020 AA שאלה 2א,"היי, תודה!
אם נתון לנו מצביע ל-successor, יכול להיות שהאמורטייזד בשאלה בעצם מיותר והסיבוכיות קבועה גם ב-WC? נשמע שאפשר פשוט לבדוק אם הוא הבן, אם כן פשוט לחתוך אותו ובכל מקרה נחתוך את האיבר עצמו מההורה שלו לכל היותר פעם אחת."
71105,תשובה ל: 2020 AA שאלה 2א,"אוקיי, האמת שכשאני חושבת על זה יכול להיות שכשנרצה לחתוך את האיבר עצמו כל ההורים שלו יהיו מסומנים ויהיה צריך לחתוך אותם עד למעלה, ואז תיתכן פעם אחת שבה הסיבוכיות תהיה לוגריתמית - לכן צריך את האמורטייזד."
71108,תשובה ל: 2020 AA שאלה 2א,"זה כן WC.
ביקשו לציין אמורטייזד למקרה והמימוש משפיע על שאר הפעולות (מה שלא קורה) וכתוצאה מכך על זמני האמורטייזד של מבנה הנתונים."
70796,2020 AB שאלה 1א,"היי, בנוגע להערה של טעויות שעשו תלמידים: אם אני אומרת שמקצה האש במימוש CHAINING, איך כדאי לנסח בבחינה התייחסות להתנגשויות, לדוגמה בקשר לסעיף המצורף? תודה רבה מראש"
70973,תשובה ל: 2020 AB שאלה 1א,יש שרשור על השאלה הזאת
70823,2020BA שאלה 5,"היי,

בפתרון הרשמי השתמשו פה ברשימת שכנים וערימה כדי למצוא בכל פעם את הסכום המקסימלי של השכנים.

רציתי לדעת האם אפשר לגשת לזה גם עם Union-FInd?

חשבתי לאתחל מערך בגודל K של ערכים שכל תא בו מחזיק את הערך ובנוסף מצביע לSET חדש שהנציג שלו הוא הסכום של כל מי שמצביע עליו.

כלומר לאחר האתחול יהיו K סטים שהמייצג שלהם הוא הערך של כל תא ושדה שנשמור בו את הset שהערך שלו מקסימלי.

בהכנסה של קשתות כל פעם כמו שלמדנו עושים union לשני הסטים הקודמים והמייצג יהיה הסכום של שניהם בתוך הסט.

מחיקה - נחסיר מכל סט שעוברים בדרך את ערך הנמחק ונמחק אותו מהרשימה.

סכום מקסימלי - בהכנסה או מחיקה בכל מקרה אנחנו משלמים logn אז נמצא כבר את המקסימום החדש מבין הסטים הנוכחיים.

אשמח להכוונה מה אני מפספס פה , והאם באופן כללי בלי קשר לפתרון שלי כן אפשר ליישם פתרון עם UNION find כאן.

תודה רבה!"
70953,תשובה ל: 2020BA שאלה 5,"המחיקה כאן בעייתית, איך אפשר לדעת מי המקסימום החדש?"
71063,תשובה ל: 2020BA שאלה 5,"עוברים על המסלול מהמצביע שלו לרכיב קשירות עם הקשת הראשונה שהוא חובר אליה ועד האחרונה (שמייצגת את הרכיב קשירות הכי גדול)
ובכל רכיב קשירות כזה בדרך דואגים להחסיר את הערך שלו מהסכום הנוכחי בכל set.
בסוף דואגים שהמצביע שלו יצביע לNewset עם הערך של עצמו בלבד"
71123,תשובה ל: 2020BA שאלה 5,"אבל בUF במימוש uptrees העץ הוא לא בינארי.
נגיד יש רכיב קשירות עם n איברים וכולם מחוברים ישירות לשורש. עכשיו כשמוחקים את המקסימום, ייקח זמן לינארי למצוא את המקסימום החדש.

באופן כללי - UF ומחיקות לא הולך ביחד"
71001,שאלה כללית - מילון,"ראיתי במספר פתרונות שאפשר לפתור שאלות עי שימוש במילון. האם כאשר אני אומרת דבר שכזה עליי להסביר את גודל טבלת ה hash והשיטה שבה עובדת?

הרי מילון ממומש כך ובפתרונות זה לא צוין."
71005,תשובה ל: שאלה כללית - מילון,"צריך לציין (או AVL, או טבלת hash עם מגודל מסויים)"
71208,שאלה כללית - לאן מקבלים מצביע,"בהמון שאלות כשאנו מתבקשים לממש מבנה נתונים מסוים עם פעולות מסוימות, מתוארת פעולה בה אנו מקבלים מצביע לאיבר וצריכים לבצע משהו עליו (למשל delete שמקבלת מצביע לאיבר ומוחקת אותו).
האם אנחנו צריכים להתייחס בהסבר על המבנה נתונים שבחרנו לאן המצביע שמקבלים אמור להצביע? כלומר מה נחשב איבר במבנה?"
71224,תשובה ל: שאלה כללית - לאן מקבלים מצביע,"בעקרון אם יש לך מבנה נתונים אחד (נגיד ערימה בודדת) אז המצביע הוא לnode שבו מופיע האיבר שלך.
אם את מתחזקת כמה מבני נתונים (נגיד עץ וגם ערימה שמכילים איברים משותפים) אז המצביע הוא לnode רק באחד ממבני הנתונים וזאת המשימה שלך (בעזרת מצביעים דו כווניים) להצליח להגיע לnode במבנה נתונים השני."
71355,2020 AA שאלה 2ב,"היי,
מצורף הסעיף והפתרון הרשמי:

כשפתרתי על השאלה בעצמי השתמשתי רק במערך, ואשמח לקבל פידבק על דרך הפתרון.
נשתמש במערך באורך 3n, ונכניס אליו את האיברים כך שהאיבר באינדקס i ייכנס לתא ה- i-1.
נשמור שני שדות גלובליים - Min, Max- האינדקסים בהם יושבים האיבר המקסימלי והמינימלי בהתאמה. 
לכל איבר במערך יהיו 3 שדות: value (הערך), min (הערך של השדה Min טרם הכנסתו), max (הערך של השדה Max טרם הכנסתו).
בעת הכנסה נעדכן את השדות הגלובליים במידה והאיבר החדש גדול מהמקסימום או קטן מהמינימום.
בכל מחיקה נעדכן את השדות הגלובליים לערכים המתאימים של השדות הלוקאליים של האיבר שמועמד למחיקה.
במימוש הזה כל הפעולות המבוקשות מתבצעות ב- O(1) WC, אז בפרט הן מתבצעות ב- O(1) amortized.

תודה רבה"
71457,תשובה ל: 2020 AA שאלה 2ב,"אין פה את הניסוח המלא של השאלה אז אנחש תשובה -
איך אפשר לדעת מה המקסימום/מינימום החדש לאחר מחיקה? נשמע כמו משהו שדורש ערימה."
71465,תשובה ל: 2020 AA שאלה 2ב,"לא מאה אחוז בטוח בזה אז אשמח לתיקון - נראה לי שזה בעייתי מבחינת התחזוק של המינימום והמקסימום (נסתכל על מינימום בהכ)

יכול להיות שנכניס איבר כך שהוא יהיה המינימום, לאחר מכן נכניס עוד איבר כך שהוא יהיה המינימום החדש אחריו, ולאחר מכן איבר נוסף שיהיה שוב המינימום החדש. אם נמחק את המינימום האמצעי לא אמור לקרות כלום כי הערך שלו גדול מהמינימום הנוכחי ולא אמור להיות עדכון, אבל אחרי זה כשנמחק את המינימום האמיתי (=החדש ביותר) לא תהיה לנו דרך להגיע למינימום המעודכן (=המינימום הישן ביותר), כי בערך הלוקאלי שלו יהיה מצביע למינימום האמצעי שכבר נמחק (ואולי הוספנו שם משהו אחר בכלל בינתיים).

באופן כללי אפשר לדמיין שניקח מערך ממויין הפוך ונכניס את הערכים שלו אחד אחרי השני למבנה הנתונים ככה שכל פעם נעדכן את המינימום הגלובלי, ואז אם נעשה סדרה של מחיקות באמצע המערך ולאחר מכן נמחק את האיבר הימני ביותר במערך (שהוא המינימום הגלובלי) לא נוכל למצוא בזמן קבוע את המינימום החדש"
71490,תשובה ל: 2020 AA שאלה 2ב,"הבנתי, תודה רבה!"
71377,2022AB שאלה 1,רשום בטעויות הנפוצות שלא הסבירו למה אפשר לבנות עץ AVL בזמן לינארי - אפשר פשוט לציין שראינו בתרגול שזה אפשרי אם המערך ממוין? 
71447,תשובה ל: 2022AB שאלה 1,כן
71458,2020-2021 AA,"היי,
יש לי 2 שאלות על שאלה 1 ממבחן 2020-2021 (בתיקיית המבחנים רשום כ-2020) סמסטר א מועד א.

1. בסעיף א' - החשיבה שלי הייתה שעדיף לי שתת המערך הראשון (בין אינדקס i0 לאינדקס i1) תהיה כמה שיותר ארוכה, ואז שאר העבודה שלי תהיה זניחה (יהיה אינדקס i_j בכל אינדקס שנשאר - למעט 1). הבנתי שגודל המערך הכי ארוך שאני יכולה לעשות בין i0 ל-i1 הוא n-n/k (כיוון שאני צריכה להשאיר n/k איברים לשאר האינדקסים). אז חשבתי למצוא את האיבר ה-n-n/k בגודלו במערך ע""י אלגוריתם ה-selection ב-O(n) ואז לעשות חלוקה לכל האיברים שקטנים ממנו וכל האיברים שגדולים ממנו ב-O(n) כמו אחד האלגוריתמים של partition שלמדנו. ואז למיין את המערך שמכיל את כל האיברים שקטנים מהאיבר שמצאנו ב-selection ב-O( (n - n/k) * log(n - n/k) ) . ופה אני מבינה שמה שהוצג בפתרון הוא בסיבוכיות יותר טובה ממה שאני אומרת אבל אני לא מצליחה להבין מה בחשיבה שלי לא טוב לגבי הדרך שבה ניגשתי לשאלה

2. בסעיף ב' - כשמבקשים ממני לספק חסם תחתון הדוק במודל ההשוואות לבעיה מסוימת - האם אני יכולה לבחור באיזו דרך לעשות את זה (למשל בעזרת עומק עץ ההשוואות המתאים או בעזרת רדוקציה לבעיה אחרת) ? או שבגלל שרשום ""במודל ההשוואות"" הכוונה לפתור רק דרך עץ ההשוואות ועומקו (כמו בתרגיל בית 5 למשל) או שהבעיה אליה אני עושה רדוקציה צריכה להיות גם במודל ההשוואות?

אשמח לעזרה, תודה
[image.png]"
71496,תשובה ל: 2020-2021 AA,"1. את לא רוצה שהמערך יהיה כמה שיותר ארוך כי את רוצה אותו ממויין וזה יקר למיין מערכים.
2. מותר בכל דרך אפשרית (ועדיף בדרכים שלמדנו - עץ השוואות, רדוקציה, שיקולי אינפורמציה)"
71549,2019 AA שאלה 4,"האם טבלת hash יכולה להיות מוגדרת עם פונקצית hash אשר התחום שלה RxR ? 

כי אני זוכר שבתרגול התייחסו לכך שפונקצית hash יכולה להיות רק מתחום הטבעיים, אשמח להבין האם אפשר להגדיר את התחום לכל קבוצה?"
71780,תשובה ל: 2019 AA שאלה 4,"ענו לי בשעת קבלה, תודה"
71836,תשובה ל: 2019 AA שאלה 4,בכבוד
72463,תשובה ל: 2019 AA שאלה 4,"היי, מה נגיד עושים פה אז בטבלת ה-hash?
כי בתרגול כל האיברים היו בין 0 לבין B אבל כאן לא נתון לנו טווח שבו הנקודות חסומות וגם לא נתון שהן רק חיוביות וגם בתרגול התעסקנו עם שלשות מספרים ופה עם זוגות"
72683,תשובה ל: 2019 AA שאלה 4,"ניסחו את השאלה לא טוב, כן היו צריכים לומר שהאיברים טבעיים בטווח חסום מ0 עד B כלשהו"
71575,2017BB שאלה 2ב,"היי

אשמח להסבר על הרדוקציה בשאלה הזו: איך נראה תהליך הכנסת האיברים לA וB על מנת להוציא את האיברים בסדר הממוין

תודה!"
71585,תשובה ל: 2017BB שאלה 2ב,"תיקח מערך לא ממוין ותמצא את המינימום שלו
תדחוף לB את המינימום ול-A את כל האיברים מלבד המינימום (עולה nloglogn להכניס הכל ל-A)
תאתחל מערך פלט ותשים בו את המינימום הכי משמאל
ואז באופן איטרטיבי:
- תריץ closest pair שיחזיר לך מ-A את האיבר הבא בסדר הממויין (כי התחלנו מהמינימום ומחקנו אותו מ-A, אז הבא ב-A שהכי קרוב למינימום יהיה זה שהכי קרוב אליו מלמעלה), שים אותו במערך פלט
- תמחק מ-B את מה שחזר מ-B - עולה loglogn
- תוסיף לB את מה שחזר מ-A - עולה loglogn
- תמחק מ-A את מה שחזר מ-A - עולה loglogn
כלומר בכל רגע נתון ב-B יש רק איבר אחד, אתה כל פעם שולף באמצעותו את המינימום של הקבוצה A ומוחק ממנה את המינימום עד שלא נשארים יותר איברים

סהכ nloglogn זמן ריצה בסתירה לחסם תחתון על מיון"
71822,תשובה ל: 2017BB שאלה 2ב,תודה אמרי
71676,מבחן 2020-2021 AA שאלה 1,"היי,

אשמח להסבר איך מוכיחים שההפרש לא יכול להיות יותר מלינארי"
71696,תשובה ל: מבחן 2020-2021 AA שאלה 1,"אינטואיטיבית ההפרש לא יכול להיות גדול אסימפטוטית מכמות האיברים כי אז זה אומר שבאחד מתתי העצים יש משמעותית יותר מ-n איברים, שזה לא אפשרי כי בעץ כולו יש n איברים
פורמלית אפשר לסמן x כמות הצמתים בתת עץ שמאלי ו-y כמות צמתים בתת עץ ימני, להניח בשלילה ש x-y זה אומגה קטנה של n ולהראות סתירה:

ואז אפשר להציב c כלשהו נגיד c=1 ולהראות שזה לא אפשרי עבור x ו-y חיוביים

אשמח לתיקונים אם זה לא מדויק"
71911,תשובה ל: מבחן 2020-2021 AA שאלה 1,הנימוק הקצר הוא x-y<=x<=n = O(n)
71690,שאלה כללית על מודל ההשוואות,"היי , 

בשאלות רבות שקשורות למודל ההשוואות וגם כמו שראינו בתרגול , אמרנו שכדי להוכיח חסם תחתון במודל ההשוואות

אנחנו יכולים לחשב את כמות הפלטים האפשריים ואז הסיבוכיות תהיה אומגה של log כמות הפלטים שמצאנו.

אני מסתבך קצת עם ההגדרה פה של פלטים ולא קלטים . בפועל כדי לבצע מיון במודל ההשוואות אנחנו בודקים את כל הפרמוטציות 

של קלטים אפשריים כי כל עוד אנחנו במודל עבור קלט מסויים נהיה חייבים להשוות בין כל שני איברים.

אשמח להבהרה , 

תודה רבה מראש"
71830,תשובה ל: שאלה כללית על מודל ההשוואות,"מדובר בלוג של כמות הפלטים.

יכול להיות אלגוריתם שבהנתן מערך באורך n מחזיר True או False. במקרה כזה עץ השוואות יביא חסם גרוע של log2 = 1.

ספציפית עבור מיון, ראינו שעבור קלט a1,...,an האלגורתם חייב להיות מסוגל להחזיר כל פרמוטציה אפשרית של הקלט הזה בתור הסדר הממויין, כלומר n! פלטים אפשריים.
חשוב להבין שהסימון a1,...an מדבר על ייצוג כללי של קלט, מבחינת עץ ההשוואות לא ידוע מה הם הערכים a_i"
71691,2019BB שאלה 9,"היי, אשמח אם אפשר להסביר יותר בפירוט את הפתרון האלטרנטיבי שהוצע, לא כל כך מצליחה להבין אותו
תודה רבה מראש!"
71715,תשובה ל: 2019BB שאלה 9,"נראה לי שבמקום להחזיק עץ AVL אחד שהמפתחות בו הם ערכי y בנקודה x=0 והערכים בו הם ערכי y בנקודה x=1 (שזה מזהה חד חד ערכי של ישר, כמו לשמור a ו-b), הם מציעים לפרק את זה לשני rank trees: אחד מכיל מפתחות שהם ערכי הy של הישרים בנקודה x=0 והשני מכיל מפתחות שהם ערכי ה-y של הישרים בנקודה x=1, ואני מניח שלתחזק מצביעים בין המופעים של הישר בשני העצים
אם הדרגה של המופע של הישר בx=0 לא שווה לדרגה של המופע שלו בx=1 - נגיד שהדרגה ב-0 קטנה ממש מהדרגה ב-1 - זה אומר שקיים לפחות ישר אחד שערך ה-y שלו ב-x=0 גדול מהערך של הישר שלנו בx=0, וגם ערך ה-y שלו ב-x=1 קטן מהערך של הישר שלנו ב-x=1, וזה בדיוק ההגדרה של הצטלבות.
נוח לחשוב על זה עם הציור בשאלה - הדרגה של הישר שצמוד לb בעץ של x=0 היא 1, אבל בעץ של x=1 היא 2, כי ההצלטבות בין הישרים גורמת להחלפה בדרגות"
71910,תשובה ל: 2019BB שאלה 9,בדיוק מה שאמרי אמר.
72340,תשובה ל: 2019BB שאלה 9,תודה רבה!!
71818,2020 AB שאלה 4 סעיף ב,"היי,
השאלה הזו הופיעה גם בתרגול האחרון, ויש בה נקודה שלא ברורה לי.
אם אנחנו מקטינים מפתח של איבר מסויים- זה לא עלול לגרום לכפילות?
יכול להיות מצב שהמפתח החדש נמצא בקבוצה אחרת. האם הכוונה היא לאחד בין הקבוצות במקרה כזה?
זה לא מפר את דרישת הסיבוכיות, אבל לא הייתה התייחסות למצב הזה כלל.

תודה רבה"
71839,תשובה ל: 2020 AB שאלה 4 סעיף ב,ניתן להניח שאין כפילויות
71867,תשובה ל: 2020 AB שאלה 4 סעיף ב,"מעולה, תודה"
71834,2020AA שאלה 1,"בפתרון כתבו שצריך לבדוק רק את המפתח + 16, ולא ציינו שיש לבדוק את המפתח - 16. זה פספוס שבאמת לא צריך לבדוק אותם?"
71840,תשובה ל: 2020AA שאלה 1,לא פספסו - אם יש זוג איברים במרחק 16 אז על בטוח יש אחד שגדול ב16 מהשני
71849,תשובה ל: 2020AA שאלה 1,תודה
71847,הפרות סדר ב-Insertion Sort,"בדף הנוסחאות כתוב שכאשר יש במערך I הפרות סדר, הסיבוכיות של המיון תהיה O(I+n).

מה זו בעצם הפרת סדר? המספר הכולל של הזזות שנצטרך לבצע? אין מצב שזה רק מספר האיברים שלא במקום, כי אז תמיד היינו מקבלים O(n).

נ.ב., האם אנחנו צריכים להדפיס את דף הנוסחאות בעצמנו או שנקבל עותק עם המבחן?"
71860,תשובה ל: הפרות סדר ב-Insertion Sort,"אני חושב שהפרות סדר זה היפוכים, כלומר זוגות אינדקסים i < j שמקיימים A[i] > A[j]
בגלל שסופרים בזוגות צריך להשתמש ב-choose ואז המקרה הגרוע הוא באמת ריבועי ולא לינארי (במערך ממויין הפוך יש n choose 2 היפוכים)
זה הגיוני ביחס לשיטת הפעולה של insertion sort - אנחנו מקדמים את הלולאה הפנימית כל עוד A[j-1] > A[j] ואז מחליפים ביניהם, כלומר עושים איטרציה וswap על כל זוג אינדקסים שהתהפכו בתוך ה-prefix הנוכחי שבודקים"
71906,תשובה ל: הפרות סדר ב-Insertion Sort,"בדיוק מה שאמרי אמר.

לא צריך להדפיס את דף הנוסחאות, הוא יצורף לבחינה"
71994,מבחן 2018AB - עלה חיצוני?,"היי, בהגדרת שאלה 9א כתוב:

דיברנו מתישהו על מה זה עלה חיצוני?"
72208,תשובה ל: מבחן 2018AB - עלה חיצוני?,"עלה וירטואלי. זאת דרך נוחה לגרום לכך שכל צומת אמיתי יהיה מלא (2 בנים, מותר שחלקם או כולם יהיה וירטואלים)"
72175,2022AA שאלה 3,"היי,

מימשתי קצת שונה ורציתי לדעת אם אפשר גם ככה או שאני טועה בניתוח סיבוכיות שלי.

במקום ערימה ביצעתי באופן רקורסיבי : select למציאת החציון ואז partition בO(n).

התנאי עצירה היה להגיע לתת מערך בגודל k . סך הכל עומק רקורסיה o(logk) כי כל מערך מתכווץ בחצי כל פעם.

אפשר כעת למיין כל מערך כזה בO(klogk), ויש n/k מערכים כאלו , לכן השקענו O(nlogK).

בכל רמה בעץ הרקורסיה אני מבצע select וpartition לסה""כ N איברים במשך logk פעמיים.

לכן ניתוח כולל פעמיים של o(nlogk)  .

שוב תודה מראש !"
72206,תשובה ל: 2022AA שאלה 3,"טעית בניתוח סיבוכיות, אם אתה מגיע למערכים באורך k אז יש n/k מערכים ולכן עומק הרקורסיה הוא logn/k"
72238,אתחול וקטור בO(1),"אהלן,
כשאנחנו מאתחלים וקטור בO1, אפשר לצאת מנק' הנחה שלאחר האתחול והכנסת הערכים יש לנו גישה למערכי positions ו Legals ולערכים בתוכם?"
72677,תשובה ל: אתחול וקטור בO(1),כן
72320,2020AA שאלה 2ב,"שלום,
בתשובות כאן הציעו ליצור טבלת hash ע""מ לקבל סיבוכיות מתאימה בתוחלת.
כשלמדנו על טבלאות hash ניתחנו סיכויי התנגשויות והתייחסות למספר האיברים, אני קצת מתקשה להבין מתי יש להתייחס לגודל הטבלה וסיכויי ההתנגשויות ומתי לא, במקרה הנוכחי לא התייחסו אבל הפתרון עלול להיות לא נכון במידה ויש התנגשות בין שני ערכי b בטבלה, כיוון שלא ידוע הטווח של b לא ניתן להבטיח שאין התנגשויות בין שני ערכי b שונים לתוצאה של פונ' ה hash, אשמח להסבר או הכוונה מתי יש להתייחס להתנגשויות ומתי לא. תודה רבה"
72361,תשובה ל: 2020AA שאלה 2ב,"הפתרון לא יהיה לא נכון אם יש התנגשות בין שני ערכי b בטבלה, זה ששני מפתחות נכנסים לchain מסויים זה לא אומר שאי אפשר להבדיל ביניהם בפעולת search, אם b=2 ו-b=1 ושניהם מתמפים במקרה לאותו התא, כשתפעיל על שניהם hash במסגרת פעולת search תגיע לאותו תא, אבל בכל פעולת search אתה תרוץ על כל הchain ותשווה את מה שאתה מחפש למה שיש בchain.

הבעיה היחידה שchains ארוכים יכולים ליצור היא לדפוק את הסיבוכיות הקבועה בתוחלת של search, insert וכו', אבל כל עוד אתה מאתחל טבלת האש שגודלה הוא תטא של n (לינארי בכמות האיברים במבנה) מובטח לך מההוכחות על סיבוכיות בתוחלת של האש שעשינו בכיתה שתוחלת האורך של כל chain היא alpha (ה-load factor), ואז באמת הכל יוצא O(1).

ככלל בשאלות האלה עדיף לעבוד עם ADT מילון, להצדיק את כל הפעולות שאתה עושה בהנחה שיש לך איזה מילון קסם שאפשר לחפש בו דברים ולקבל את הvalues שמקושרים אליהם, ובסוף לומר שמימשת עם hashtable בגודל n אז כל הפעולות שתיארת בסיבוכיות קבועה בתוחלת"
72407,תשובה ל: 2020AA שאלה 2ב,תודה רבה על המענה אבל עדיין לא הבנתי מתי אני יכול לענות בהתייחסות לADT מילון ומתי אני צריך ממש להתייחס לגודל הטבלה ביחס לכמות האיברים
72684,תשובה ל: 2020AA שאלה 2ב,"במהלך האלגוריתם אתה מתייחס לADT מילון (ולא אכפת לך שהוא hash).

רק בניתוח הסיבוכיות יש חשיבות לגודל הטבלה וכמות האיברים שהוכנסו.

שלושת השורות שאמרי רשם מעולות, ממליץ להבין אותן"
72464,2020BA שאלה 6,אני לא מצליח להבין מדוע הפתרון הנתון הוא כמות החילופים.  אשמח לעזרה
72498,תשובה ל: 2020BA שאלה 6,"תיקח מערך [4,3,2,1] שיש בו 6 חילופים (ממויין יורד)
אתה מוסיף את 4 לעץ, מתקיים n = 1 וrank(x) = 1 אז sum =0
אחרי זה מוסיף את 3 לעץ, מתקיים n = 2 ו-rank(x) = 1 אז sum = 1
אחרי זה מוסיף את 2 לעץ, מתקיים n=3 ו-rank(x) = 1 אז sum = 3
אחרי זה מוסיף את 1 לעץ, מתקיים n=4 ו-rank(x) = 1 אז sum =6
קיבלנו את התשובה הנדרשת

זה מחזיר בדיוק את כמות ההיפוכים שx משתתף בהם כי:
נגיד שאני עכשיו מכניס לעץ דרגות את האיבר ה-x במערך (שנמצא במקום ה-i במערך המקורי)
הערך n הוא בעצם המקום של x במערך המקורי + 1 (יעני i+1), ו-treerank(x) זה כמות האיברים y שמקיימים שני תנאים: y קטן מ-x, וגם y נמצא משמאל ל-x במערך המקורי (כי אני מכניס את האיברים משמאל לימין, אז מי שנמצא ב-rankים יותר קטנים מ-x בעץ כרגע זה מי שקטן ממנו וגם נמצא משמאלו).
נשים לב שאלה לא איברים בעייתיים, כי אם איבר נמצא משמאלי והוא גם קטן ממני אז זה לא היפוך. היפוך זה כשהוא נמצא משמאלי והוא גם *גדול* ממני.
לכן אנחנו עושים n - treerank(x), זה נותן בדיוק את כמות האיברים y שמקיימים: y גדול מ-x, וגם y נמצא משמאל ל-x במערך המקורי. 
זה בדיוק כמות ההיפוכים שהאיבר הזה משתתף בהם יחד עם איברים שנמצאים משמאלו.

כול להיות שהאיבר הזה משתתף בהיפוך גם יחד עם איבר אחר z שנמצא מימינו במערך המקורי, אבל זה סבבה כי אני אספור את ההיפוך הזה כשאגיע לאיבר z, ואספור את ההיפוכים שy משתתף בהם יחד עם איברים שנמצאים משמאלו.
מקווה שזה ברור :)"
72548,2021BB שאלה 4,"היי,

פתרתי את השאלה הזו בדרך קצת שונה מהדרך שהציגו בפתרון הרשמי. אשמח לדעת האם זה מתקבל:

נגדיר יחס סדר על 2 נקודות במישור: (a,b) > (c,d) אם""ם a>b וגם c>d.

נכניס לעץ AVL נקודות במישור לפי יחס הסדר שהגדרנו ונתחזק שדה size.

Init: נאתחל עץ ריק.

Insert: נכניס את (a,b) לעץ.

DomDiff: נכניס את (a,b) לעץ -> נחשב את n-Rank((a,b)) - (Rank((a,b)) - 1) -> נמחק את (a,b) מהעץ -> נחזיר את הערך שחישבנו (n-Rank((a,b)): מס' הנקודות השולטות, Rank((a,b)) - 1: מס' הנקודות הנשלטות).

הסיבוכיות של הפעולות Insert, DomDiff היא O(logn).

זה הפתרון הרשמי:

תודה"
72682,תשובה ל: 2021BB שאלה 4,זה לא יחס סדר בגלל שאי אפשר להשוות כל 2 מפתחות.
72686,תשובה ל: 2021BB שאלה 4,למה אי אפשר להשוות כל 2 מפתחות?
72933,תשובה ל: 2021BB שאלה 4,"אתה הגדרת יחס סדר על 2 נקודות במישור: (a,b) > (c,d) אם""ם a>b וגם c>d.
אם הנקודות שלך הן :
(4,1) = x
(4,2) = y
לפי ההגדרה שלך אתה מקבל ש x>y וגם y>x.."
72956,תשובה ל: 2021BB שאלה 4,"נכון, אבל כתוב בשאלה שניתן להניח שערכי ה-a וערכי ה-b של כל 2 נקודות שונים זה מזה.
זה לא פותר את הבעיה?"
72969,תשובה ל: 2021BB שאלה 4,"אם הנקודות שלך הן :
(4,1) = x
(5,2) = y
לפי ההגדרה שלך אתה מקבל ש x>y וגם y>x..
הבעיה היא שאתה לא באמת מבצע השוואה בין x לy (הנקודות השונות)."
72984,תשובה ל: 2021BB שאלה 4,"אה נכון, התבלבלתי כשכתבתי פה בפורום. רציתי להגדיר יחס סדר כזה: (a,b) > (c,d) אם""ם a>c וגם b>d.
זה יעבוד לא?"
72995,תשובה ל: 2021BB שאלה 4,"עדיין לא.. קח למשל מקרה של הכלה
(1,5) = x
(2,4) = y"
73016,תשובה ל: 2021BB שאלה 4,"הבנתי, תודה"
72557,2018ab שאלה 1ד,היי :) אשמח להסבר על הפתרון של סעיף ד'. לא כלכך איך הבנתי איך האלגוריתם הזה יעבוד. לא אמורים להכניס את האיברים לעץ AVL כדי שנוכל להשתמש בהנחה בשלילה? 
72590,תשובה ל: 2018ab שאלה 1ד,"כשהם אומרים מיזוגים רקורסיביים הם מתכוונים שבתנאי עצירה של הרקורסיה יוצרים עץ avl מגודל 1/2, ואז העלייה חזרה מהרקורסיה ממזגת את הavlים האלה לכדי avl בגודל n. אם נניח בשלילה שקיימת פונקציה כזו merge, זה ייראה משהו בסגנון הזה:

זה ממש מבלבל לחשוב על זה ככה בעיניי, עדיף לחשוב על זה bottom up - לוקחים מערך לא ממויין, בוחרים מתוכו n/2 זוגות רנדומליים של איברים, על כל זוג עושים merge, אחרי זה ממזגים בזוגות את הn/2 זוגות ומקבלים n/4 עצי AVL בגודל 4, וכך הלאה עד שנקבל עץ AVL אחד בגודל n - נוציא ממנו inorder ונקבל את המערך ממויין. הרקורסיה עושה בדיוק את זה רק הפוך (מלמעלה למטה) והנוסחת נסיגה של זה היא באמת מה שכתוב בתשובות כי עלות ה-merge היא שורש של גודל המערך שעליו עובדים."
72629,תשובה ל: 2018ab שאלה 1ד,תודה לך! איך חישבת את נוסחת הנסיגה? עם עץ רקורסיה? כי אני לא כלכך מצליחה לעשות את זה עם רקורסיה.
72648,תשובה ל: 2018ab שאלה 1ד,"איך מגיעים אליה או איך מחשבים אותה?
מגיעים אליה דרך זה שבכל שלב ברקורסיה קוראים רקורסיבית לmerge על שני התתי מערכים של הקלט הנוכחי, כל אחד באורך חצי מהקלט הנוכחי, והעלות של merge היא למזג שני עצים שגודלם יחד n
פותרים עם שיטת המאסטר, זה המקרה הראשון"
72873,הפיכת מערך לערימה ב-O(n),"היי,

אם אני לא טועה הראינו איך הופכים מערך לערימה ב-O(n) רק בערימה בינארית.

האם זה אפשרי גם לשאר סוגי הערימות? ואם כן, האם ניתן להשתמש בזה במבחן ללא הוכחה?

תודה מראש"
72897,תשובה ל: הפיכת מערך לערימה ב-O(n),"בערימת פיבונאצ'י וערימה בינומית עצלה בכל מקרה ההכנסות הן בO(1) אז האתחול שלהן הוא בO(n)
בערימה בינומית אפשר להוכיח שהאתחול שלה הוא בO(n) כמו שראינו במונה הבינארי בתרגול (רק שפונקציית הפוטנציאל תהיה כמות העצים במקום כמות האחדות)"
73287,תשובה ל: הפיכת מערך לערימה ב-O(n),תודה שרון
72937,2020 AB שאלה 4,"מדובר שאלה שראינו שתרגול 13, רציתי לשאול מה בניסוח השאלה אומר לנו להשתמש במימוש העצים ההפוכים ולא הרשימות המקושרות ב union find? הם מבקשים את זמן הריצה אמורטייזד המהיר ביותר שתוכלו. אני לא מבין איך קבעו שמימוש העצים ההפוכים מהיר יותר, כי למשל פעולת ה find היא Oׂ)1( במימוש על ידי רשימות מקושרות."
72962,תשובה ל: 2020 AB שאלה 4,"להבנתי, הבעיה נובעת בפעולת הUnion, שלוקחת לנו O(logn) אמורטייזד במימוש רשימות מקושרות.
לעומת זאת במימוש העצים ההפוכים אנחנו מקבלים זמני אמורטייזד של inverse ackerman, שקטן אפילו מlog*(n)."
72964,תשובה ל: 2020 AB שאלה 4,"חושב שמימוש up-trees הוא יותר טוב ממימוש רשימות מקושרות באופן כללי, כי יש הבדל משמעותי בין ה-union ב-logn אמורטייזד שאתה מקבל מהרשימות המקושרות ובין הunion ב-O(1) שאתה מקבל מהמימוש up-trees. ההבדל בין O(1) לאקרמן עבור find זניח לעומתו, במימוש uptrees החסם על find הוא פרקטית קבוע כמו שלמדנו בכיתה"
73223,תשובה ל: 2020 AB שאלה 4,"הבנתי, תודה רבה"
72958,2022BB שאלה 2ב,"לא הבנתי בשאלה הזו את המשמעות של החזרת (i,j) - זה לא האינדקסים של המערך המקורי וגם לא הערכים של המערך המקורי

להבנתי בשאלה רצו להחזיר את הערכים הכי קרובים לחציון אז לא היה צריך להחזיר את A[i], A[j]?"
72967,תשובה ל: 2022BB שאלה 2ב,בנוסף - היה אפשר למיין לפי ההפרשים מהחציון ואז לעבור על המערך מקטן לגדול ולהחזיר את הפעם הראשונה שיש שני הפרשים זהים? (להחזיר את ההפרש פלוס החציון יחד עם החציון פחות ההפרש)? הם בהכרח ההפרשים הזהים הכי קטנים
72968,תשובה ל: 2022BB שאלה 2ב,"נראה לי שאת צודקת וזה טעות בניסוח, צריך להחזיר את A[i], A[j]"
73469,תשובה ל: 2022BB שאלה 2ב,"כן, צודקת"
72989,2022BB שאלה 4,איך סעיף א׳ עונה על השאלה אם לא ביקשו O(n) אמורטייז? 
73001,תשובה ל: 2022BB שאלה 4,"אם יש לך סדרה של n פעולות שכל אחת מהן היא O(1) אמורטייזד, אז העלות הכוללת של הסדרה היא O(n). (זה חסם לכל סדרה של n פעולות, כלומר גם עבור המקרה הגרוע)"
73003,תשובה ל: 2022BB שאלה 4,"אם זמן האמורטייזד של הכנסה הוא קבוע ועושים n פעולות הכנסה, זמן הריצה של סדרת הפעולות הוא O(n) לא אמורטייזד
בשביל לגזור זמני אמורטייזד מחשבים את הזמן שלוקח בפועל לn פעולות ואז מחלקים בn - הזמן ריצה של הסדרה כולה הוא לא אמורטייזד, אבל החלוקה של העבודה באופן שווה על פני כל פעולה בודדת באמצעות חלוקה בn זה מה שנקרא אמורטייזד (כי זה לא נכון שכל פעולה עושה O(1), יש פעולות זולות ויש פעולות יקרות באופן שנסכם בסוף לO(n))
מתוך השיעור:"
73026,2019AA שאלה 4,"בהרצאות ובתרגול למדנו שכדי לממש טבלת hash ביעילות, נדרשת פונקציה אוניברסלית. ראינו פונקציות שעובדות על מספרים שלמים, אך לא על מספקים ממשיים. לטווח של ממשיים אין פונקציה אוניברסלית ואז סיבוכיות הטבלה נפגעת.

איך מימשו פונקציה כזו, בשאלה זו?

האם זה בסדר לכתוב הסבר כזה? (""נשתמש בפונקציית האש אשר התחום שלה  הוא R^2"")

תודה"
73031,תשובה ל: 2019AA שאלה 4,"https://moodle.tau.ac.il/2022/mod/forum/discuss.php?d=50999
יש פה תשובה של דני"
73114,2021AB שאלה 3,"אהלן , 

יש לי שאלה לגבי הדרך שפתרתי בסעיף ג' .

בהינתן ויש לי עץ נחמד מלא אז יש לי בדיוק ערך עליון של N/2 עלים . 

נבנה מערך בגודל לינארי רק מהעלים של העץ (נניח על ידי הפיכת לרשימה מקושרת) בזמן לינארי.

נמיין את העץ וניקח שוב את העלים - לכן מיינו בזמן קטן מהחסם התחתון של מיון.

האם אפשר היה להראות ככה גם? איזה פירוט נוסף הייתי צריך לומר פה על היחס סדר בין כל זוג עלים ? כי להבנתי לא חייב להיות כזה 

בכלל הם יכולים להיות כמעט כל פרמוטציה אפשרית של מספרים... 

תודה רבה!"
73571,תשובה ל: 2021AB שאלה 3,"התבלבלת בכוון של הרדוקציה.

יש לך קופסה שחורה שבהנתן עץ נחמד מחזירה את איבריו ממויינים.

עכשיו אתה רוצה להגיע לסתירה על ידי זה שאתה בונה אלגוריתם מיון מהיר. בהינתן מערך אתה רוצה לבנות עכשיו עץ נחמד ולהעזר בקופסה השחורה עליו"
73176,2021AA שאלה 4,"אשמח אם מישהו יוכל להסביר איך ניתוח הזמנים של הפיתרון יוצא O(n). 
חיפוש רשימת עוקבים וקודמים לכל מפתח במקרה הגרוע הוא n, והתוחלת היא רק על החיפוש עצמו, אז איך זה לא n בריבוע? "
73195,תשובה ל: 2021AA שאלה 4,"תשים לב שבאופן המתואר בשאלה, אנחנו לא נחזור על בדיקה של איבר פעמיים, משום שאנחנו מוחקים אותם. (וזה בסדר למחוק אותם כי כל מספר הוא חלק מרצף מקסימלי יחיד). לכן O(n)"
73521,תשובה ל: 2021AA שאלה 4,מה ששרה אמרה
73190,טבלאות האש במבחן,"שלום, יש לי שאלה על טבלאות Hash במבחן:

כמשתמשים בטבלת האש במבחן, צריך לציין איך מגדירים את פונקציית ההאש עבור הטבלה או שמספיק לרשום למשל ""טבלת האש במימוש צ'יינינג""?

תודה רבה"
73516,תשובה ל: טבלאות האש במבחן,"אין צורך לציין את הפונקציה. (כן מומלץ שתבינו שמה שקרה מאחורי הקלעים זה שככל הנראה המשפחה האוניברסלית שלכם היא משפחת המודולו p,m ולכן האלגוריתם הגריל מספרים a,b והפונקצייה והפונקציית hash היא h(x) = (ax+b mod p) mod m)"
73225,עץ/ערימה עם מפתחות כפולים,"היי,

אני לא כ""כ מבין איך מתחזקים עץ AVL או ערימה עם מפתחות כפולים.
בפרט, איך מחפשים מפתח במבנה נתונים כזה?

תודה"
73244,תשובה ל: עץ/ערימה עם מפתחות כפולים,"היי יכול לצרף דוגמא?
בערימה אין עם זה בעיה כי אפשר להגדיר את כלל הערימה בצורה יותר חלשה: הילדים של צומת x גדולים שווים מצומת x (עבור ערימת מינימום בה""כ)
זה דורש רק שינויים מינוריים בפעולות השונות כמו נגיד להגדיר בheapify down שאם שני הילדים זהים וכלל הערימה מופר, נבחר אחד רנדומלי ונחליף איתו (במקום להחליף תמיד עם הבן המינימלי)

ב-AVL נראה לי שהדרך המקובלת להתמודד עם זה היא להחזיק ב-value של כל מפתח קאונטר נוסף שסופר כמה מופעים של המפתח הזה יש / רשימה של מצביעים למופעים השונים. לרוב אין סיבה להחזיק בתוך העץ שני מפתחות זהים"
73519,תשובה ל: עץ/ערימה עם מפתחות כפולים,"בדיוק מה שאמרי אמר.

אגב - בתור עדיפויות זה אפילו די סטנדרטי שיש מפתחות כפולים. במילון פחות סטנדרטי והמימוש שאמרי הציע זאת אכן הדרך להתמודד עם זה (או במידה ויש גם value שלווה למפתח אז נשמור עבור מפתח רשימה מקושרת של כל הvalues המתאימים לו)"
73429,יחס סדר,"היי,

כשלא נתון לי יחס סדר, אני צריך ממש להגדיר את היחס סדר או שמספיק להניח שקיים יחס סדר?

תודה"
73512,תשובה ל: יחס סדר,צריך להגדיר (לרוב זה יהיה יחס סדר לקסיקוגרפי)
79210,שחזור עץ בינארי מpre order,"היי בתרגול כתוב שלא ניתן לשחזר עץ בינארי באופן יחיד מpre order אבל בדף נוסחאות כתוב שכן, אשמח לדעת מה נכון :)

מהתרגול-

מהדף נוסחאות-

תודהה"
79220,תשובה ל: שחזור עץ בינארי מpre order,הסתדרתי תודה
79325,2019AA שאלה 1,"בפתרון לשאלה התייחסו לכך שניתן שהמפתחות בעץ AVL יהיו ממשיים, האם זה אפשר גם בערימות למיניהן ? באיזה מבני נתונים זה לא אפשרי? כי למיטב זכרוני הדגשנו שמפתחות הם טבעיים."
80124,תשובה ל: 2019AA שאלה 1,"בעצי AVL וערימות כל מה שהיה חשוב זה שיש יחס סדר על המפתחות.

המקרה שבו היה חשוב שהמפתחות יהיה טבעיים היה כאשר משתמשים בhashing בגלל שהמשפחות האוניברסליות שהגדרנו היו מהטבעיים."
79336,2019AA שאלה 2א,"אין תשובה רשמית, האם ניתן לבצע כאן החלפת בצמתים אליהם מצביעים המצביעים? במידה ולא האם יש דרך אחרת לבצע את זה?"
80138,תשובה ל: 2019AA שאלה 2א,"יש שרשור על הסעיף הזה.

להחליף את הצמתים זה יקר מידי כי צריך לשנות יותר מדי מצביעים.
אפשר במקום להחליף את הkey וה value של הצמתים"
79394,2019AA שאלה 3ב,מתי מאתחלים פה את המערך? איפה הסיבוכיות של האתחול נלקחת בחשבון? מדובר על וקטור?
80136,תשובה ל: 2019AA שאלה 3ב,ראינו שאתחול מערך אפסים לוקח O(1) ב WC. לכן ניתן לאתחל את המערך תוך כדי השאילתא הראשונה על מבנה הנתונים
80528,2016AA שאלה 13,"[אשמח להסבר איך הגיעו לתשובה, חוץ מזה גם את ההערה שכתובה בצד למטה לא ככ ברור לי איך מוכיחים. תודה.]"
80529,תשובה ל: 2016AA שאלה 13,"אשמח להסבר איך מגיעים לתשובה, וכן גם להערה למטה שלא ככ ברור לי איך מוכיחים אותה."
80551,תשובה ל: 2016AA שאלה 13,"בבירור לא אכפת לנו מהאיברים שבמרכז כי הם כבר איפה שצריכים להיות.
לכן נותרו לנו רק 2sqrt(n) איברים למיין. באופן נאיבי זה לוקח sqrt(n)logn שזאת גם הסיבוכיות שמופיעה בסעיף ג.
המידע לגבי כמות החילופים נועד רק לבלבל. ידוע מ insertion sort שאם במערך באורך n יש x חילופים אז ניתן למיין אותו ב n+x זמן. ספציפית אנחנו ממיינים רק 2sqrt(n) איברים ולכן insertion sort לא משפר לנו את הסיבוכיות של מיון רגיל.
הערה שצירפת למטה היא אלגוריתם insertion sort מבוסס עצי AVL (שלא נלמד הסמסטר) שהסיבוכיות שלו היא n + nlog(x/n). (באופן כללי insertion sort באיטרציה ה i ממיין את i האיברים הראשונים במערך, המימוש בעזרת עצי AVL מתבסס על finger למקסימום ובאיטרציה הi מכניסים את האיברים הi לעץ)."
81050,21BA שאלה 3,"היי אשמח לעזרה בנוגע להסבר על הכנסה וחיפוש בעץ. נתון שהאינטרוולים הם שונים ומוכלים אחד בשני אבל לא הובטח לנו שכל שני אינטרוולים שונים בשתי נק הקצה שלהם (לדוגמא אינטרוול [2,4] ואינטרוול [2,3] שבבירור שונים ואכן אחד מוכל בשני). לא ברור אם כך איך מבצעים חיפוש והכנסה בעץ אם קיימים שני אינטרוולים שאחת מנק הקצה שלהם שוות.[21BA 3]"
81227,תשובה ל: 21BA שאלה 3,"לא חושב שהתכוונו בשאלה שיהיו מקרים כאלו אבל בכל מקרה אפשר לפתור התנגשויות כאלו באופן הבא:

יחס הסדר בעץ יהיה טיפה יותר מתוחכם במידה ויש שיוויון. אם יש 2 נקודות קצה זהות והן נקודות התחלה אז נגדיר את נקודת הקצה של האינטרוואל הארוך יותר להיות השמאלית יותר. אם מדובר בנקודות סיום אז נגדיר את נקודת הקצה של האינרטרוואל הארוך יותר להיות הימנית יותר.
בשביל שנוכל לבצע את ההשוואות האלו אז נשמור בעץ חוץ מהkey גם data שיספר לנו האם אנחנו נקודת קצה ימנית/שמאלית ומי נקודת הקצה השנייה."
81255,2018AA Q1,"היי , אשמח לעזרה בתרגיל הזה. לא הבנתי את ההסבר גם :)
תודה!"
81492,תשובה ל: 2018AA Q1,"אלגוריתמי ה selection שראינו בכיתה תמיד לקחו איבר pivot, עשו סביבו partition ואז המשיכו ל1 מצדדי המערך (אם ה pivot הוא מי שחיפשנו אז אפילו יותר טוב ומסיימים).

בגלל שכל צעד pivot המערך קטן בלפחות אחד ובגלל שלאלגוריתם לקחח 0.75n צעדים אז אפשר להבין שרוב הזמן גודל המערך היה לינארי.
למשל ב 0.25n צעדים הראשונים, אנחנו יודעים שיש עוד לפחות 0.5n צעדים ובפרט אורך המערך כרגע הוא לפחות 0.5n. כלומר העלות של ה0.25n צעדים הראשונים היא לינארית (כי אורך המערך הוא לינארי) מה שמביא סיבוכיות ריבועית.

בנימוק שלהם הם דיברו על מקרי הקיצון והנסכמים שמופיעים שם הם אורכי המערכים לאורך האיטרציות (בסדר הפוך).
אם אנחנו יודעים שלקח בדיוק 0.75 איטרציות אז -
הכי טוב היה אם מיד באיטרציה הראשונה זרקנו רבע מהמערך ואז בכל אחת מהאיטרציות הבאות זרקנו רק איבר אחד (זה מה שמתואר בשורה הראשונה, צריך להיות שם גם גורם של n בגלל האיטרציה הראשונה).
הכי גרוע זה אם כל איטרציה אנחנו זורקים רק איבר אחד ורק באיטרציה האחרונה (כשיש עוד 0.25n איברים) נמצא את מי שחיפשנו. (זה מה שמתואר בשורה השניה)."
82054,תשובה ל: 2018AA Q1,תודה רבה!
81267,2018 BA שאלה 1,"היי ,

לגבי סעיף ג׳ . בפתרון פה הציעו לכפול בN^3 ואז לעגל את המספר שקיבלנו. אבל נתון שהמספרים רחוקים בלפחות 1/n^3  . לא הצלחתי להבין למה שזה תמיד יעבוד למשל בדוגמה הבאה: n=10 והמספרים הם 1/100,000 וכן הלאה עד 1 חלקי מיליון. אחרי הכפל ופעולת העיגול נקל פה בעצם שכולם זה אותו מספר - 0 או 1.

תודה מראש!"
81495,תשובה ל: 2018 BA שאלה 1,"המספרים כן יוצאים שונים אחרי העיגול.

יכול לחזור על מה המספרים שהצגת?"
81517,תשובה ל: 2018 BA שאלה 1,"כן , התכוונתי למשל אם n=10 אז יוצא שהמרחק בין כל צמד לפחות אלפית . אבל מה שאני חשבתי זה שבגלל שהטווח הוא אינסופי אם ניקח שברים קטנים מספיק גם אחרי שנכפיל בn^3 , בדוגמה שלי 1000 נקבל מספרים בין 0 ל1 שהעיגול שלהם הוא 0 או 1 בלבד. למשל הסדרה הבאה כקלט בסדר אקראי: 1 חלקי מאה אלף , 1 חלקי 200 אלף וכן הלאה… מקיימת את התנאי אבל העיגול יצא לכולם 0 אחרי כפל ב1000,

תודה!"
81641,תשובה ל: 2018 BA שאלה 1,נתון אבל שהמרחק הוא לפחות אלפית והסדרה שלך לא מקיימת את זה
81317,2015BB שאלה 1א,"היי,אשמח לעזרה בשאלה,תודה."
81494,תשובה ל: 2015BB שאלה 1א,"1)ממיינים בזמן לינארי על ידי radix sort בבסיס n.
2) סורקים את המערך הממויין עם 2 מצביעים. אם ההפרש בין המצביעים קטן מs אז מקדמים את המצביע הגדול, אחרת מקדמים את המצביע הקטן."
81811,2020AA שאלה 2א,האם לא ניתן לפתור בעזרת עץ avl יחיד כשאר אנו מגדירים את יחס הסדר בין הטאפלים? כלומר היחס יקבע לפי הרכיב השני ובמקרה של שוויון לפי הרכיב הראשון? 
81922,תשובה ל: 2020AA שאלה 2א,כן זה גם סבבה.
81856,2017AB שאלה 4ב,היי אשמח לעזרה בסעיף הזה. היה לי רעיון שכולל בתוכו עץ AVL (או אולי אפילו באמצעות ערימות) עם מצביע לחציון לאיבר מינימלי ומקסימלי בכדי שאוכל להחזיר בO(1) במקרה הגרוע. מבחינת מחיקה ועידכון החציון חשבתי להגיד שגם ככה ההכנסה משלמת logn אז היא פשוט תשלם גם עבור עידכון החציון ועבור מחיקה בכדי שהן יעלו O(1) באמורטייזד (בפרט הכנסה שהעבירה את מבנה הנתונים ממצב שהוא בגודל n לגודל n+1 תשלם על המחיקה שתקטין את המבנה מגודל n+1 לn...).  לא ככ בטוח בפיתרון שלי ובנימוק לסיבוכיות האמורטייזד.[17AB]
81858,תשובה ל: 2017AB שאלה 4ב,[ב]
81920,תשובה ל: 2017AB שאלה 4ב,"כן זה בדיוק הפתרון, לחייב את כל העלויות לinsert.

נגיד והעלות של כל הכנסה ומחיקה היא logn כולל עדכונים המצביעים למינימום, חציון ומקסימום.

מה שאפשר לעשות אז הוא על כל הכנסה לקבל 2logn שמתוכם logn משלמים על ההכנסה של האיבר וה logn הנותרים ישלמו על המחיקה העתידית של האיבר. בכל שאר הפעולות נקבל רק מטבע אחד."
81957,2020AA שאלה 5א,"אשמח להבין באיזה אופן זה שימש אותנו שהמערך מעגלי? אני מבינה שאנחנו עובדים עם mod אבל יכלנו לעשות זאת גם עם מערך רגיל. בפרט מה לא היה עובד לו הייתי מממשת עם מערך רגיל?

(מצ״ב גם קובץ הפיתרון בשלמותו)"
81981,תשובה ל: 2020AA שאלה 5א,"צודקת לגמרי, מדובר בסתם מערך (בלי קשר לADT רשימה שבה דיברנו על מימוש עם מערך מעגלי) שמשתמשים בו ""בצורה מעגלית""."
81966,2022BB שאלה 3,"הנה השאלה והפתרון:

מדוע לא משתנה פעולת האיחוד? הרי לכל אחד ממבני הנתונים יש רשימת משקלים וצריך לאחד אותן כדי לשמור על נכונות הפתרון.

אם צריך לאחד את הרשימות, יתכן מקרה שלכל איבר משקל שונה ואז האיחוד הוא ב- O(n)."
82061,תשובה ל: 2022BB שאלה 3,יש רק רשימת משקלים אחת והיא גלובאלית (לא מדובר על רשימת משקלים פר קבוצה). מתחזקים מצביעים בין הצמתים ברשימת המשקלים ולבין הצמתים בUF
82074,תשובה ל: 2022BB שאלה 3,"אם רשימת המשקלים היא גלובלית, ורוצים להוציא את רשימת האיברים הממוינת במבנה ספציפי לפי המשקלים, צריך לעבור על כל איבר ברשימה ולבדוק לאיזה מבנה הוא שייך.
כלומר, נצטרך לבצע על כל איבר ברשימה הגלובלית find כדי לבדוק שהוא נמצא במבנה UF הרלוונטי. ב- up trees כל פעולה כזו עולה O(log n) ואז סך הכול נקבל O(n log n), זמן לא לינארי."
82062,2017 Bb  שאלה 1 סעיף ד',"היי אשמח לעזרה בסעיף ד' של השאלה הזו: 

תודה רבה"
82149,תשובה ל: 2017 Bb  שאלה 1 סעיף ד',"בהמשך לשאלה,אשמח לדעת האם הפתרון הבא תקין:
תחזוק שני עצי AVL עבור A ו-B,כאשר ב-A נתחזק מצביע לחציון העליון והתחתון ונסמן אותם כa,b,לאחר מכן נשתמש בפעולה מהתרגול SeperateInterval  עם התחום (a,b) עבור העץ B,אם העץ של החיתוך לא ריק נחזיר TRUE."
82070,17AA שאלה 1ד,"היי אשמח להסבר מדוע אפשר להתעלם מפעולות undo, גם מבחינת הנימוק שנתנו שם על פעולת ההכנסה וההוצאה מהמחסנית וגם על העובדה שחוץ מהשליפה מהמחסנית כן צריך לבצע שינויים במבנה הנתונים (לפי כתובת הזיכרון ששלפנו) ואליהם לא התייחסו...

[1ד]

[1ד]"
82187,2018AB שאלה 2 סעיף ב,"אני מנסה לפתור את השאלה הבאה:

להלן פתרון השאלה:

לפי הפיתרון כאשר מתבצעת הפעולה Add(i,x) אנו מוסיפים באמצעות פעולת Insert ( גם אם ה-ID קיים) את הערך x לערימת פיבונאצי מסוג מקסימום ומתחזקים את המצביעים בהתאם. לא היינו יכולים לבצע Increasekey שכן כפי שראינו בתרגול זו פעולה מסיבוכיות O(logn) אמורטייזד

מה שמתקבל זה שישנם איברים בערימה שבעקבות זה שלא ביצענו להם מחיקה הם ללא מצביעים מתאימים (אני מניח שהתא ה-i עודכן להיות עם מצביעים חדשים  לצומת חדש בערימה לאחר פעולת ה-Insert) 

ובעצם יכולים להיות צמתים בערימה בעלי ערכי AMOUNT ""שגוי"" ,כלומר, הם חסרי מצביעים, ובנוסף, יכולים לשמש כאיבר המקסימלי (לפיכך יכולים להיות סדרה כזו) ואז כשמבצעים WhoIsMax בעצם נוצרת לנו בעיה.

האם אני מפספס משהו? תודה מראש על העזרה!"
82202,תשובה ל: 2018AB שאלה 2 סעיף ב,"אני חושב שהסתדרתי, פעולת Increasekey הינה מסיבוכיות O(1) אמורטייזד בערימת פיבונאצ'י מסוג מקסימום שכן הפעולות מתהפכות עבור פעולה זו עם DecreaseKey."
82199,2022BB שאלה 4,"אשמח להבין מה הכוונה לבצע n הכנסות? אני הרי צריכה לבנות את הערימה (המקרה הזה עץ בינומי בודד. מדרגה k) לפי חוקיות מסוימת, אז איך בפועל נבנה העץ? "
82209,3א 2023AA,"האם אפשר לממש את 3א מהמבחן עם perfect hashing?
כלומר בכל תא נשמור counter ובעת הכנסה נכניס רגיל ונוסיף 1 לcounter בתא של xmodn

תודה!!"
82240,2023AA q4b,"היי, ניסיתי לפתור את 4B מהמבחן , ויצאה לי דרך קצת אחרת אשמח לדעת האם הפתרון טוב/ הערות . תודה רבה"
82244,תרגיל בית. 5 שאלה 3.,"שתי שאלות -  מדוע הסימונים האסימפטוטים משתנים בסעיף  א אל מול ב? כלומר מה מאפשר לנו לקבוע חסם עליון בסעיף א אבל חסם תחתון בסעיף ב? 

ושאלה שנייה, לעניין החישוב עצמו - מדוע בסעיף ב התוצאה היא nloglogn ולא nlogn? 

תודה "